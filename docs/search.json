[
  {
    "objectID": "quarto/about.html",
    "href": "quarto/about.html",
    "title": "About",
    "section": "",
    "text": "Pending"
  },
  {
    "objectID": "LICENSE.html",
    "href": "LICENSE.html",
    "title": "",
    "section": "",
    "text": "Code\n\n\n\n\n\nMIT License\nCopyright (c) 2026 Cryptococcus cost analysis authors\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Overview",
    "section": "",
    "text": "Cryptococcosis in kidney transplant recipients is uncommon but potentially catastrophic. When transmission occurs through the donor, it often presents early after transplant, may involve the central nervous system, and is associated with substantial morbidity and mortality despite treatment.\nThe costs of cryptococcus after solid organ transplant are unclear. Although studies have quantified the cost of a single hospitalization for cryptococcus, no study to date has estimated the total excess cost of care due to cryptococcus."
  },
  {
    "objectID": "index.html#clinical-background",
    "href": "index.html#clinical-background",
    "title": "Overview",
    "section": "",
    "text": "Cryptococcosis in kidney transplant recipients is uncommon but potentially catastrophic. When transmission occurs through the donor, it often presents early after transplant, may involve the central nervous system, and is associated with substantial morbidity and mortality despite treatment.\nThe costs of cryptococcus after solid organ transplant are unclear. Although studies have quantified the cost of a single hospitalization for cryptococcus, no study to date has estimated the total excess cost of care due to cryptococcus."
  },
  {
    "objectID": "index.html#what-this-analysis-does",
    "href": "index.html#what-this-analysis-does",
    "title": "Overview",
    "section": "What this analysis does",
    "text": "What this analysis does\nThis project uses the United States Renal Data System to analyze the impact of cryptococcus on costs."
  },
  {
    "objectID": "index.html#methods",
    "href": "index.html#methods",
    "title": "Overview",
    "section": "Methods",
    "text": "Methods\nWe selected cryptococcus cases based on the following inclusion criteria:\n\nAge 18 or greater\nPrior kidney transplant\nICD9 or ICD10 codes for cryptococcus (2 outpatient or 1 inpatient)\nOne year of Medicare primary coverage lead-in\n\nControls were matched 2:1 to cases based on risk-set sampling on the following:\n\nTime since transplant\nDiabetes\nHIV/AIDS\nAge within 10 years\nSampling date for control within 3 years of sampling date for case\n\nInstitutional claims data were abstracted as well as Physician/Supplier line-item data."
  },
  {
    "objectID": "index.html#results",
    "href": "index.html#results",
    "title": "Overview",
    "section": "Results",
    "text": "Results\nPending"
  },
  {
    "objectID": "index.html#site-navigation",
    "href": "index.html#site-navigation",
    "title": "Overview",
    "section": "Site navigation",
    "text": "Site navigation\n\nCreate cohort: Creation of cohort\nAbout: methods, assumptions, and disclosures\n\n\nReproducibility\nAll analyses presented on this website are fully reproducible.\nThe complete source code used to perform the full analysis and generate the tables and figures is publicly available at this GitHub repo. The R script R/main.R will run the R subscripts needed for this analysis in the order they are to be run. Model assumptions, parameter values, and analytic workflows are documented in the repository to facilitate transparency and reuse."
  },
  {
    "objectID": "index.html#abstractsmanuscripts",
    "href": "index.html#abstractsmanuscripts",
    "title": "Overview",
    "section": "Abstracts/manuscripts",
    "text": "Abstracts/manuscripts\nThis analysis has yet to be published to date."
  },
  {
    "objectID": "quarto/create_cohort.html",
    "href": "quarto/create_cohort.html",
    "title": "Create cohort",
    "section": "",
    "text": "The code in this script creates the cohort of kidney transplant patients eligible for the study for use in other scripts.\n\n\n\n\n\n\nSource code\n\n\n\nThe full R script is available at:\n\nR/create_cohort.R\n\nThis R script file is itself reliant on the following helper files:\n\nR/setup.R\nR/functions.R\n\n\n\n\n\nThis portion of the code imports files from the USRDS data set necessary for the cryptococcus analysis. This portion makes use of the load_usrds_data() function from the usRds package as well as several tidyverse cleaning functions.\nKey files used:\n\npatients: This is a part of the Core data set of the USRDS and contains key patient demographics.\ntx: Also a part of the Core data set of the USRDS and contains summary information about kidney transplants from UNOS.\ntxunos_trr_ki and txunos_trr_kp: Part of the transplant data set of the USRDS, these files contain more detailed information derived from UNOS that is part of the Scientific Registry of Transplant Recipients.\n\nThe code below loads and merges transplant records across multiple UNOS-derived files, constructs a cumulative transplant count per patient, and reshapes the data into a time-varying format that tracks graft status over time.\n\n\nCode\n#Import core demographics from \"patients\" file\npatients_raw&lt;-usRds::load_usrds_file(\"patients\")%&gt;%\n  select(-ZIPCODE) #This is ZIP code at time of USRDS initiation, but we want at time of crypto dx\n\n#Import key information about the transplants from the TX and UNOS databases\ntx_raw&lt;-usRds::load_usrds_file(\"tx\")%&gt;%\n  select(USRDS_ID, TDATE, FAILDATE, TRR_ID_CODE)\n\nki_raw&lt;-usRds::load_usrds_file(\"txunos_trr_ki\")%&gt;%\n  select(USRDS_ID, ORGTYP, HRTX, LUTX, INTX, LITX,PITX,BMTX, TRR_ID_CODE)\n\nkp_raw&lt;-usRds::load_usrds_file(\"txunos_trr_kp\")%&gt;%\n  select(USRDS_ID, ORGTYP, HRTX, LUTX, INTX, LITX,PITX,BMTX, TRR_ID_CODE)\n\n#This combines the three datasets\ntx_clean&lt;-tx_raw%&gt;%\n  left_join(bind_rows(ki_raw,\n                      kp_raw))%&gt;%\n  arrange(USRDS_ID, TDATE)%&gt;%\n  \n  group_by(USRDS_ID)%&gt;%\n  mutate(cumulative_transplant_total=row_number())%&gt;%\n  ungroup\n\n#Create a time-varying dataset that can be used to track whether a pt has an active or inactive graft and the cumulative number of txs\ntx_status&lt;-tx_clean%&gt;%\n  select(USRDS_ID, TDATE, FAILDATE, cumulative_transplant_total)%&gt;%\n  pivot_longer(\n    cols = c(TDATE, FAILDATE),\n    names_to = \"event_type\",\n    values_to = \"event_date\"\n  ) %&gt;%\n  filter(!is.na(event_date)) %&gt;%\n  mutate(\n    graft_status = case_when(\n      event_type == \"TDATE\" ~ \"Active\",\n      event_type == \"FAILDATE\" ~ \"Failed\"\n    )\n  ) %&gt;%\n  select(-event_type)%&gt;%\n  arrange(USRDS_ID, cumulative_transplant_total, event_date, graft_status)\n\n\n\n\n\nThe next component makes use of the flowchart package. This package combines two key processes in an epidemiologic analysis:\n\nDataset preparation: Sequential application of eligibility criteria to define the analytic cohort, with explicit tracking of excluded records at each step.\nSTROBE diagram preparation: STrengthening the Reporting of OBservational studies in Epidemiology diagrams visually depict the process of including/excluding patients in an observational study and grouping them into cohorts. Many journals require these as a standard Figure 1.\n\nThe code below initializes a flowchart-aware cohort object and applies sequential eligibility filters, retaining both inclusion counts and labeled exclusion steps for downstream reporting.\n\n\nCode\n#Initialize a flowchart cohort\npatients_clean&lt;-patients_raw%&gt;%\n  as_fc(label=\"Patients in USRDS\")%&gt;%\n  \n  \n  fc_filter(TOTTX&gt;0, \n            label=\"Prior transplant\", \n            label_exc = \"Excluded: No prior transplant\", \n            show_exc = TRUE)%&gt;%\n  \n  fc_filter(TX1DATE&lt;as.Date(\"2021-01-01\"), \n            label=\"Transplant prior to 2021\", \n            label_exc = \"Excluded: Transplant 2021 or later\", \n            show_exc = TRUE)\n\n\n\n\n\nThis component identifies baseline comorbidities among transplant recipients using diagnosis codes derived from Medicare Institutional (Part A) and physician/supplier (Part B) claims. Diagnosis code lists defined in R/setup.R are applied uniformly across claims files to establish the presence and timing of comorbid conditions.\nThis portion makes use of the get_IN_ICD() and get_PS_ICD() functions from the usRds package to obtain dates that specific ICD codes are used for patients with a history of at least one kidney transplant in the study period.\nThe establish_dx_date() function from the usRds package uses the results of this analysis to ascertain the date when comorbidities meet the criteria for a formal diagnosis:\n\nTwo outpatient encounters or\nOne inpatient encounter\n\nIn parallel, Medicare coverage history is retrieved for all transplant recipients from the payhist file, which is part of the Core dataest. These data will be used to confirm continuous enrollment during the analytic period. We verify the absence of gaps indicating missing data, noting that every subsequent period in the dataset for a patient starts the day after the previous period ends and thereby supporting valid longitudinal assessment of diagnoses and downstream cost analyses.\nFinally, we separate cryptococcus diagnosis dates from other comorbidities for a separate list, given the key nature of the date of cryptococcus diagnosis for subsequent analyses.\n\n\nCode\n#Create list of USRDS ids for patients who have undergone transplant\ntransplant_id_list&lt;-patients_clean$data%&gt;%\n  pull(USRDS_ID)\n\n# We now seek to determine comorbidities by using diagnosis codes from the setup.R file\n\ncomorbidity_diagnosis_date&lt;-list()\n\n# Combine all ICD codes from all comorbidities into one list \ncomorbidity_ICD_combined_list&lt;-unlist(comorbidity_ICD_list, use.names=FALSE)\n\n#Scrape files for any comorbidity claim\ncomorbidity_claims_df&lt;-bind_rows(get_IN_ICD(icd_codes = comorbidity_ICD_combined_list, \n                                            years = 2006:2021, \n                                            usrds_ids = transplant_id_list ),\n                                 get_PS_ICD(icd_codes = comorbidity_ICD_combined_list, \n                                            years = 2006:2021, \n                                            usrds_ids = transplant_id_list )%&gt;%rename(CODE=DIAG))%&gt;%\n  arrange(USRDS_ID, CLM_FROM)\n\n#Create comorbidity_diagnosis_date data frame\nfor (comorbidity in names(comorbidity_ICD_list)){\n  \n  comorbidity_diagnosis_date[[comorbidity]]&lt;-comorbidity_claims_df%&gt;%\n    filter(CODE %in% comorbidity_ICD_list[[comorbidity]])%&gt;%\n    establish_dx_date(diagnosis_established = comorbidity)\n}\n\n#Load Medicare coverage history for all patients with transplant\nmedicare_history&lt;-load_usrds_file(\"payhist\",\n                                  usrds_ids = transplant_id_list)%&gt;%\n  arrange(USRDS_ID, BEGDATE)%&gt;%\n  group_by(USRDS_ID)%&gt;%\n  mutate(lag_ENDDATE=lag(ENDDATE))%&gt;%\n  mutate(gap=as.numeric(BEGDATE-lag_ENDDATE))%&gt;%\n  arrange(desc(gap))\n\n#Confirm no gaps (gap should always be 1 or missing)\nif (any(!is.na(medicare_history$gap) & medicare_history$gap != 1)) {\n  stop(\"Gap assumption violated: `gap` contains values other than 1 or NA.\")\n}\n\n\n#Format a df with the cryptococcus dx\ncryptococcus_df&lt;-comorbidity_diagnosis_date$cryptococcus%&gt;%\n  select(-diagnosis)%&gt;%\n  rename(cryptococcus_dx_date=date_established)\n\n\n\n\n\nSubsequently, key diagnosis dates, including the date of cryptococcosis diagnosis, are merged into the analytic patient dataset.\nThis code block then extends the STROBE flowchart by integrating diagnosis timing, eligibility criteria, and coverage requirements to finalize the analytic cohorts. Patients are classified as cryptococcosis cases or potential controls based on the presence and timing of diagnosis, and sequential exclusion criteria are applied to ensure incident disease, adult status at diagnosis, and appropriate calendar-time eligibility.\nThe verify_medicare_primary() function from the usrds package is used to confirm that patients with a cryptococcus diagnosis have Medicare primary coverage for at least 365 days prior to the cryptococcus diagnosis date to ensure that the diagnosis is new and not a carryover from an unobserved period.\nThese steps culminate in the final case and control cohorts, with all inclusion and exclusion decisions explicitly tracked and visualized in the updated STROBE flow diagram.\n\n\nCode\n#Join cryptococcus date to fc cohort\npatients_clean$data&lt;-left_join(patients_clean$data, \n                               cryptococcus_df)%&gt;%\n  mutate(cryptococcus_case=ifelse(is.na(cryptococcus_dx_date), \"Potential control\", \"Case\"))\n\n#Continue to create analytic cohort\npatients_merged&lt;-patients_clean%&gt;%\n  \n  #Remove patients with a diagnosis of cryptococcus prior to transplant\n  fc_filter(cryptococcus_dx_date&gt;TX1DATE | is.na(cryptococcus_dx_date), \n            label=\"No cryptococcus dx prior to transplant\", \n            label_exc = \"Excluded: cryptococcus dx prior to transplant\", \n            show_exc = TRUE)%&gt;%\n  \n  fc_filter((time_length(interval(BORN, cryptococcus_dx_date), \"years\") &gt;= 18) | is.na(cryptococcus_dx_date),\n            label=\"Age 18+ at time of cryptococcus if cryptococcus patient\", \n            label_exc = \"Excluded: First cryptococcus prior to age 18\", \n            show_exc = TRUE)%&gt;%\n  \n  fc_filter((year(cryptococcus_dx_date)&gt;=2007 & year(cryptococcus_dx_date)&lt;=2020) | is.na(cryptococcus_dx_date),\n            label=\"Incident cryptococcus between 1/1/2007 and 12/31/2020\", \n            label_exc = \"Incident cryptococcus outside of specified date range\", \n            show_exc = TRUE)%&gt;%\n  \n  #Split cohorts\n  fc_split(cryptococcus_case)\n  \n  #Check Medicare coverage for 365-day lookback period from day of first episode of cryptococcus\npatients_merged$data&lt;-patients_merged$data%&gt;%\n  verify_medicare_primary(index_date = \"cryptococcus_dx_date\",\n                          lookback_days = 365,\n                          coverage_start_variable = \"coverage_start_date\",\n                          coverage_end_variable = \"coverage_end_date\"\n                          )%&gt;%\n  mutate(medicare_primary_TF=ifelse(cryptococcus_case==\"Potential control\", TRUE, medicare_primary_TF))\n  \npatients_merged2&lt;-patients_merged%&gt;%\n  \n  fc_filter(medicare_primary_TF==TRUE, \n            label = \"365+ days of Medicare primary coverage\\nprior to first cryptococcus claim\", \n            label_exc = \"Excluded: Fewer than 365 days of coverage\",\n            show_exc = TRUE)\n\npatients_merged2$data&lt;-patients_merged2$data%&gt;%\n  select(-medicare_primary_TF)%&gt;%\n  \n  #Prepare data for cohort initialization\n  mutate(terminal_date=coalesce(coverage_end_date, censor_date))\n\npatients_merged2&lt;-patients_merged2%&gt;%\n  fc_filter((terminal_date - cryptococcus_dx_date &gt;=minimum_followup) | is.na(cryptococcus_dx_date), \n            label = \"Minimum followup exceeded\", \n            label_exc= \"Excluded: Minimum follow-up threshold not met\",\n            show_exc = TRUE)\n\n  \npatients_merged2%&gt;%\n  fc_draw()\n\n\n\n\n\nWe use several functions from the usRds package:\n\ncreate_usrds_cohort()\nadd_cohort_covariate()\nfinalize_usrds_cohort()\n\nThese functions split each patient into multiple rows, with each row describing a discrete period of time. This captures that patients will have time-varying status for covariates such as cirrhosis status, etc.\nPatients with cryptococcus infection join the cohort on the date of cryptococcosis diagnosis, while patients without cryptococcus (potential controls) join on the date of their first kidney transplant.\n“Time since transplant” resets after each new transplant.\n\n\nCode\n#Now we need to construct the time-varying data set\n\n#Ungroup\ninitial_cohort&lt;-patients_merged2$data%&gt;%\n  ungroup()%&gt;%\n\n#Cases join when they experience cryptococcus\n#Controls start on date of first transplant\n  mutate(\n    cohort_join_date = coalesce(\n      as.Date(cryptococcus_dx_date),\n      as.Date(TX1DATE)\n    )\n  )\n\n#Initialize cohort\nprematching_cohort&lt;-create_usrds_cohort(df=initial_cohort,\n                            start_date = \"cohort_join_date\",\n                            end_date = \"terminal_date\")%&gt;%\n  \n  # Add cirrhosis\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"cirrhosis\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"cirrhosis\")%&gt;%\n  \n  # Add CMV\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"CMV\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"CMV\")%&gt;%\n  \n  # Add diabetes\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Diabetes\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"diabetes\")%&gt;%\n  \n  # Add HIV\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"HIV\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"HIV\")%&gt;%\n  \n  # Add liver transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Liver transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"liver_transplant\")%&gt;%\n  \n  # Add lung transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Lung transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"lung_transplant\")%&gt;%\n  \n  # Add heart transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Heart transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"heart_transplant\")%&gt;%\n  \n  # Add pancreas transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Pancreas transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"pancreas_transplant\")%&gt;%\n  \n  # Add heart-lung transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Heart-lung transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"heartlung_transplant\")%&gt;%\n  \n  # Add intestinal transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Intestinal transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"intestinal_transplant\")%&gt;%\n  \n  #Add time-varying information about transplant status\n  add_cohort_covariate(covariate_data_frame=tx_status,\n                       covariate_date=\"event_date\",\n                       covariate_variable_name=\"cumulative_transplant_total\",\n                       covariate_value = \"cumulative_transplant_total\")%&gt;%\n  \n  #Add time-varying information about transplant status (whether current graft is active or failed)\n  add_cohort_covariate(covariate_data_frame=tx_status,\n                       covariate_date=\"event_date\",\n                       covariate_variable_name=\"current_graft_status\",\n                       covariate_value = \"graft_status\")%&gt;%\n  \n  #Add time-varying information about transplant status (date of most recent transplant)\n  add_cohort_covariate(covariate_data_frame=tx_status%&gt;%filter(graft_status==\"Active\"),\n                       covariate_date=\"event_date\",\n                       covariate_variable_name=\"most_recent_transplant_date\",\n                       covariate_value = \"event_date\")%&gt;%\n  \n  #Add time-varying information about transplant status (date of most recent graft failure)\n  add_cohort_covariate(covariate_data_frame=tx_status%&gt;%filter(graft_status==\"Failed\"),\n                       covariate_date=\"event_date\",\n                       covariate_variable_name=\"most_recent_failure_date\",\n                       covariate_value = \"event_date\")%&gt;%\n  \n  # Add Medicare current coverage\n  add_cohort_covariate(covariate_data_frame=medicare_history,\n                       covariate_date=\"BEGDATE\",\n                       covariate_variable_name=\"current_medicare_coverage\",\n                       covariate_value = \"PAYER\"\n                       )%&gt;%\n  \n  finalize_usrds_cohort(baseline_date_variable = \"most_recent_transplant_date\")\n\n\nThe analysis then proceeds on to the execute_matching component.\n\n\n\n\nSetup\nExecute matching\nAbout: methods, assumptions, and disclosures"
  },
  {
    "objectID": "quarto/create_cohort.html#create-cohort",
    "href": "quarto/create_cohort.html#create-cohort",
    "title": "Create cohort",
    "section": "",
    "text": "The code in this script creates the cohort of kidney transplant patients eligible for the study for use in other scripts.\n\n\n\n\n\n\nSource code\n\n\n\nThe full R script is available at:\n\nR/create_cohort.R\n\nThis R script file is itself reliant on the following helper files:\n\nR/setup.R\nR/functions.R"
  },
  {
    "objectID": "quarto/create_cohort.html#other-portions-of-the-analysis",
    "href": "quarto/create_cohort.html#other-portions-of-the-analysis",
    "title": "Create cohort",
    "section": "",
    "text": "Setup\nExecute matching\nAbout: methods, assumptions, and disclosures"
  },
  {
    "objectID": "quarto/create_cohort.html#section",
    "href": "quarto/create_cohort.html#section",
    "title": "Create cohort",
    "section": "",
    "text": "Code\n#Create a cohort of kidney transplant patients with cryptococcus matched to controls without cryptococcus\n\nsource(\"R/setup.R\")\n\n#Import core demographics from \"patients\" file\npatients_raw&lt;-usRds::load_usrds_file(\"patients\")%&gt;%\n  select(-ZIPCODE) #This is ZIP code at time of USRDS initiation, but we want at time of crypto dx\n\n#Import key information about the transplants from the TX and UNOS databases\ntx_raw&lt;-usRds::load_usrds_file(\"tx\")%&gt;%\n  select(USRDS_ID, TDATE, FAILDATE, TRR_ID_CODE)\n\nki_raw&lt;-usRds::load_usrds_file(\"txunos_trr_ki\")%&gt;%\n  select(USRDS_ID, ORGTYP, HRTX, LUTX, INTX, LITX,PITX,BMTX, TRR_ID_CODE)\n\nkp_raw&lt;-usRds::load_usrds_file(\"txunos_trr_kp\")%&gt;%\n  select(USRDS_ID, ORGTYP, HRTX, LUTX, INTX, LITX,PITX,BMTX, TRR_ID_CODE)\n\n#This combines the three datasets\ntx_clean&lt;-tx_raw%&gt;%\n  left_join(bind_rows(ki_raw,\n                      kp_raw))%&gt;%\n  arrange(USRDS_ID, TDATE)%&gt;%\n  \n  group_by(USRDS_ID)%&gt;%\n  mutate(cumulative_transplant_total=row_number())%&gt;%\n  ungroup\n\n#Create a time-varying dataset that can be used to track whether a pt has an active or inactive graft and the cumulative number of txs\ntx_status&lt;-tx_clean%&gt;%\n  select(USRDS_ID, TDATE, FAILDATE, cumulative_transplant_total)%&gt;%\n  pivot_longer(\n    cols = c(TDATE, FAILDATE),\n    names_to = \"event_type\",\n    values_to = \"event_date\"\n  ) %&gt;%\n  filter(!is.na(event_date)) %&gt;%\n  mutate(\n    graft_status = case_when(\n      event_type == \"TDATE\" ~ \"Active\",\n      event_type == \"FAILDATE\" ~ \"Failed\"\n    )\n  ) %&gt;%\n  select(-event_type)%&gt;%\n  arrange(USRDS_ID, cumulative_transplant_total, event_date, graft_status)\n\n\n#Initialize a flowchart cohort\npatients_clean&lt;-patients_raw%&gt;%\n  as_fc(label=\"Patients in USRDS\")%&gt;%\n  \n  \n  fc_filter(TOTTX&gt;0, \n            label=\"Prior transplant\", \n            label_exc = \"Excluded: No prior transplant\", \n            show_exc = TRUE)%&gt;%\n  \n  fc_filter(TX1DATE&lt;as.Date(\"2021-01-01\"), \n            label=\"Transplant prior to 2021\", \n            label_exc = \"Excluded: Transplant 2021 or later\", \n            show_exc = TRUE)\n\n\n\n#Create list of USRDS ids for patients who have undergone transplant\ntransplant_id_list&lt;-patients_clean$data%&gt;%\n  pull(USRDS_ID)\n\n# We now seek to determine comorbidities by using diagnosis codes from the setup.R file\n\ncomorbidity_diagnosis_date&lt;-list()\n\n# Combine all ICD codes from all comorbidities into one list \ncomorbidity_ICD_combined_list&lt;-unlist(comorbidity_ICD_list, use.names=FALSE)\n\n#Scrape files for any comorbidity claim\ncomorbidity_claims_df&lt;-bind_rows(get_IN_ICD(icd_codes = comorbidity_ICD_combined_list, \n                                            years = 2006:2021, \n                                            usrds_ids = transplant_id_list ),\n                                 get_PS_ICD(icd_codes = comorbidity_ICD_combined_list, \n                                            years = 2006:2021, \n                                            usrds_ids = transplant_id_list )%&gt;%rename(CODE=DIAG))%&gt;%\n  arrange(USRDS_ID, CLM_FROM)\n\n#Create comorbidity_diagnosis_date data frame\nfor (comorbidity in names(comorbidity_ICD_list)){\n  \n  comorbidity_diagnosis_date[[comorbidity]]&lt;-comorbidity_claims_df%&gt;%\n    filter(CODE %in% comorbidity_ICD_list[[comorbidity]])%&gt;%\n    establish_dx_date(diagnosis_established = comorbidity)\n}\n\n#Load Medicare coverage history for all patients with transplant\nmedicare_history&lt;-load_usrds_file(\"payhist\",\n                                  usrds_ids = transplant_id_list)%&gt;%\n  arrange(USRDS_ID, BEGDATE)%&gt;%\n  group_by(USRDS_ID)%&gt;%\n  mutate(lag_ENDDATE=lag(ENDDATE))%&gt;%\n  mutate(gap=as.numeric(BEGDATE-lag_ENDDATE))%&gt;%\n  arrange(desc(gap))\n\n#Confirm no gaps (gap should always be 1 or missing)\nif (any(!is.na(medicare_history$gap) & medicare_history$gap != 1)) {\n  stop(\"Gap assumption violated: `gap` contains values other than 1 or NA.\")\n}\n\n#Add cryptococcus diagnosis date to patients_clean$data\n#First, format a df with the cryptococcus dx\ncryptococcus_df&lt;-comorbidity_diagnosis_date$cryptococcus%&gt;%\n  select(-diagnosis)%&gt;%\n  rename(cryptococcus_dx_date=date_established)\n\n\n\n#Join cryptococcus date to fc cohort\npatients_clean$data&lt;-left_join(patients_clean$data, \n                               cryptococcus_df)%&gt;%\n  mutate(cryptococcus_case=ifelse(is.na(cryptococcus_dx_date), \"Potential control\", \"Case\"))\n\n#Continue to create analytic cohort\npatients_merged&lt;-patients_clean%&gt;%\n  \n  #Remove patients with a diagnosis of cryptococcus prior to transplant\n  fc_filter(cryptococcus_dx_date&gt;TX1DATE | is.na(cryptococcus_dx_date), \n            label=\"No cryptococcus dx prior to transplant\", \n            label_exc = \"Excluded: cryptococcus dx prior to transplant\", \n            show_exc = TRUE)%&gt;%\n  \n  fc_filter((time_length(interval(BORN, cryptococcus_dx_date), \"years\") &gt;= 18) | is.na(cryptococcus_dx_date),\n            label=\"Age 18+ at time of cryptococcus if cryptococcus patient\", \n            label_exc = \"Excluded: First cryptococcus prior to age 18\", \n            show_exc = TRUE)%&gt;%\n  \n  fc_filter((year(cryptococcus_dx_date)&gt;=2007 & year(cryptococcus_dx_date)&lt;=2020) | is.na(cryptococcus_dx_date),\n            label=\"Incident cryptococcus between 1/1/2007 and 12/31/2020\", \n            label_exc = \"Incident cryptococcus outside of specified date range\", \n            show_exc = TRUE)%&gt;%\n  \n  #Split cohorts\n  fc_split(cryptococcus_case)\n  \n  #Check Medicare coverage for 365-day lookback period from day of first episode of cryptococcus\npatients_merged$data&lt;-patients_merged$data%&gt;%\n  verify_medicare_primary(index_date = \"cryptococcus_dx_date\",\n                          lookback_days = 365,\n                          coverage_start_variable = \"coverage_start_date\",\n                          coverage_end_variable = \"coverage_end_date\"\n                          )%&gt;%\n  mutate(medicare_primary_TF=ifelse(cryptococcus_case==\"Potential control\", TRUE, medicare_primary_TF))\n  \npatients_merged2&lt;-patients_merged%&gt;%\n  \n  fc_filter(medicare_primary_TF==TRUE, \n            label = \"365+ days of Medicare primary coverage\\nprior to first cryptococcus claim\", \n            label_exc = \"Excluded: Fewer than 365 days of coverage\",\n            show_exc = TRUE)\n\npatients_merged2$data&lt;-patients_merged2$data%&gt;%\n  select(-medicare_primary_TF)%&gt;%\n  \n  #Prepare data for cohort initialization\n  mutate(terminal_date=coalesce(coverage_end_date, censor_date))\n\npatients_merged2&lt;-patients_merged2%&gt;%\n  fc_filter((terminal_date - cryptococcus_dx_date &gt;=minimum_followup) | is.na(cryptococcus_dx_date), \n            label = \"Minimum followup exceeded\", \n            label_exc= \"Excluded: Minimum follow-up threshold not met\",\n            show_exc = TRUE)\n\n  \npatients_merged2%&gt;%\n  fc_draw()\n\n\n#Now we need to construct the time-varying data set\n\n#Ungroup\ninitial_cohort&lt;-patients_merged2$data%&gt;%\n  ungroup()%&gt;%\n\n#Cases join when they experience cryptococcus\n#Controls start on date of first transplant\n  mutate(\n    cohort_join_date = coalesce(\n      as.Date(cryptococcus_dx_date),\n      as.Date(TX1DATE)\n    )\n  )\n\n#Initialize cohort\nprematching_cohort&lt;-create_usrds_cohort(df=initial_cohort,\n                            start_date = \"cohort_join_date\",\n                            end_date = \"terminal_date\")%&gt;%\n  \n  # Add cirrhosis\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"cirrhosis\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"cirrhosis\")%&gt;%\n  \n  # Add CMV\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"CMV\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"CMV\")%&gt;%\n  \n  # Add diabetes\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Diabetes\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"diabetes\")%&gt;%\n  \n  # Add HIV\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"HIV\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"HIV\")%&gt;%\n  \n  # Add liver transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Liver transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"liver_transplant\")%&gt;%\n  \n  # Add lung transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Lung transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"lung_transplant\")%&gt;%\n  \n  # Add heart transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Heart transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"heart_transplant\")%&gt;%\n  \n  # Add pancreas transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Pancreas transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"pancreas_transplant\")%&gt;%\n  \n  # Add heart-lung transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Heart-lung transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"heartlung_transplant\")%&gt;%\n  \n  # Add intestinal transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Intestinal transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"intestinal_transplant\")%&gt;%\n  \n  #Add time-varying information about transplant status\n  add_cohort_covariate(covariate_data_frame=tx_status,\n                       covariate_date=\"event_date\",\n                       covariate_variable_name=\"cumulative_transplant_total\",\n                       covariate_value = \"cumulative_transplant_total\")%&gt;%\n  \n  #Add time-varying information about transplant status (whether current graft is active or failed)\n  add_cohort_covariate(covariate_data_frame=tx_status,\n                       covariate_date=\"event_date\",\n                       covariate_variable_name=\"current_graft_status\",\n                       covariate_value = \"graft_status\")%&gt;%\n  \n  #Add time-varying information about transplant status (date of most recent transplant)\n  add_cohort_covariate(covariate_data_frame=tx_status%&gt;%filter(graft_status==\"Active\"),\n                       covariate_date=\"event_date\",\n                       covariate_variable_name=\"most_recent_transplant_date\",\n                       covariate_value = \"event_date\")%&gt;%\n  \n  #Add time-varying information about transplant status (date of most recent graft failure)\n  add_cohort_covariate(covariate_data_frame=tx_status%&gt;%filter(graft_status==\"Failed\"),\n                       covariate_date=\"event_date\",\n                       covariate_variable_name=\"most_recent_failure_date\",\n                       covariate_value = \"event_date\")%&gt;%\n  \n  # Add Medicare current coverage\n  add_cohort_covariate(covariate_data_frame=medicare_history,\n                       covariate_date=\"BEGDATE\",\n                       covariate_variable_name=\"current_medicare_coverage\",\n                       covariate_value = \"PAYER\"\n                       )%&gt;%\n  \n  finalize_usrds_cohort(baseline_date_variable = \"most_recent_transplant_date\")"
  },
  {
    "objectID": "quarto/setup.html",
    "href": "quarto/setup.html",
    "title": "Create cohort",
    "section": "",
    "text": "The code in this script imports libraries, initializes constants, and performs other such preparatory work for the main analysis.\n\n\n\n\n\n\nSource code\n\n\n\nThe full R script is available at:\n\nR/setup.R"
  },
  {
    "objectID": "quarto/setup.html#setup",
    "href": "quarto/setup.html#setup",
    "title": "Create cohort",
    "section": "",
    "text": "The code in this script imports libraries, initializes constants, and performs other such preparatory work for the main analysis.\n\n\n\n\n\n\nSource code\n\n\n\nThe full R script is available at:\n\nR/setup.R"
  },
  {
    "objectID": "quarto/setup.html#libraries",
    "href": "quarto/setup.html#libraries",
    "title": "Create cohort",
    "section": "Libraries",
    "text": "Libraries\nThe analysis relies on a set of open-source R packages for data management, cohort construction, visualization, and statistical modeling. These libraries were selected based on their stability, community support, and suitability for large-scale longitudinal health data.\n\n\nCode\n# Libraries necessary for the analysis\n\n#Data management libraries\nlibrary(tidyverse)\nlibrary(lubridate)\n\n#Core library for the USRDS\nlibrary(usRds)\n\n#Flowchart libraries\nlibrary(strobe)\nlibrary(flowchart)\n\n#Table libraries\nlibrary(gt)\nlibrary(gtsummary)\n\n#Plotting libraries\nlibrary(ggplot2)\nlibrary(ggbeeswarm)\nlibrary(patchwork)\n\n#Statistical modeling libraries\nlibrary(glmmTMB)\nlibrary(emmeans)\nlibrary(geepack)\nlibrary(broom)\nlibrary(broom.mixed)\nlibrary(multcomp)\n\n\nThe table below lists the required packages along with links to their primary documentation.\n\n\n\n\n\n\n\n\nRequired R Packages\n\n\nLibraries used for data processing, visualization, and statistical modeling\n\n\nCategory\nR package\nDocumentation\n\n\n\n\nData management\ntidyverse\ntidyverse.org\n\n\nData management\nlubridate\nlubridate.tidyverse.org\n\n\nUSRDS-specific\nusRds\nGitHub – usRds\n\n\nFlowcharting\nstrobe\nGitHub – strobe\n\n\nFlowcharting\nflowchart\nCRAN – flowchart\n\n\nTables\ngt\ngt documentation\n\n\nTables\ngtsummary\ngtsummary documentation\n\n\nPlotting\nggplot2\nggplot2.tidyverse.org\n\n\nPlotting\nggbeeswarm\nCRAN – ggbeeswarm\n\n\nPlotting\npatchwork\npatchwork documentation\n\n\nStatistical modeling\nglmmTMB\nCRAN – glmmTMB\n\n\nStatistical modeling\nemmeans\nCRAN – emmeans\n\n\nStatistical modeling\ngeepack\nCRAN – geepack\n\n\nStatistical modeling\nbroom\nbroom documentation\n\n\nStatistical modeling\nbroom.mixed\nbroom.mixed documentation\n\n\nStatistical modeling\nmultcomp\nCRAN – multcomp"
  },
  {
    "objectID": "quarto/setup.html#constants",
    "href": "quarto/setup.html#constants",
    "title": "Create cohort",
    "section": "Constants",
    "text": "Constants\nA number of analysis parameters are reused across cohort construction, matching, and cost modeling steps.\nThese constants are defined in the R/setup.R file.\n\n\nCode\n#Constants\ncensor_date&lt;-as.Date(\"2022-01-01\")\nminimum_followup&lt;-1 #Minimum followup in days\nmaximum_followup&lt;-365 #Maximum followup in days\nnumber_controls_per_case&lt;-2 #Number of controls per case\ninflation_month&lt;-\"January\"\ninflation_year&lt;-2021\nbaseline_months_cost&lt;-3 #N\nfull_months &lt;- -baseline_months_cost:11 #Range of months for longitudinal analysis\n\n\nFor clarity, these constants are summarized below along with brief explanations of their role in the analysis.\n\n\n\n\n\n\n\n\nAnalysis Constants\n\n\nMatching, follow-up, and cost-model parameters\n\n\nConstant\nValue\nExplanation\n\n\n\n\ncensor_date\n2022-01-01\nAdministrative censoring date for follow-up\n\n\nminimum_followup\n1\nMinimum required follow-up time (days)\n\n\nmaximum_followup\n365\nMaximum allowed follow-up time (days)\n\n\nnumber_controls_per_case\n2\nNumber of matched controls per case\n\n\ninflation_month\nJanuary\nReference month for cost inflation adjustment\n\n\ninflation_year\n2021\nReference year for cost inflation adjustment\n\n\nbaseline_months_cost\n3\nNumber of months included in baseline cost window prior to index date\n\n\nfull_months\n-3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11\nMonth indices used for longitudinal cost analysis"
  },
  {
    "objectID": "quarto/setup.html#lists-of-icd-codes",
    "href": "quarto/setup.html#lists-of-icd-codes",
    "title": "Create cohort",
    "section": "Lists of ICD codes",
    "text": "Lists of ICD codes\nLists of ICD-9-CM and ICD-10-CM diagnosis codes were used to define cryptococcosis and relevant comorbid conditions. These code sets were curated prior to analysis and include both legacy ICD-9 codes and corresponding ICD-10 codes to allow consistent identification of conditions across the study period.\nFor appropriate references, see:\n\nhttps://cdn-links.lww.com/permalink/kn9/b/kn9_2025_06_05_roetker_1_sdc2.pdf\n\n\n\nCode\n#Create list of ICD9 and ICD10 codes for cryptococcus\ncryptococcus_ICD_list&lt;-c(\"1175\", \"3210\", \"B450\", \"B451\", \"B452\", \"B453\", \"B457\", \"B458\", \"B459\", \"B45\")\n\ncomorbidity_ICD_list&lt;-list()\n\ncomorbidity_ICD_list[[\"cryptococcus\"]]&lt;-c(\"1175\", \"3210\", \"B450\", \"B451\", \"B452\", \"B453\", \"B457\", \"B458\", \"B459\", \"B45\")\n\ncomorbidity_ICD_list[[\"HIV\"]]&lt;-c(\"042\",\n                                 \"07953\",\n                                 \"V08\",\n                                 \"79571\",\n                                 \"B20\",\n                                 \"Z21\"\n                                 )\n\n\ncomorbidity_ICD_list[[\"Heart transplant\"]]&lt;-  c(\"V421\",  # ICD-9-CM: Heart transplant status\n                                                \"Z941\")  # ICD-10-CM: Heart transplant status\ncomorbidity_ICD_list[[\"Heart-lung transplant\"]]&lt;-c(\"Z943\") # ICD-10-CM: Heart and lungs transplant status\ncomorbidity_ICD_list[[\"Lung transplant\"]]&lt;-  c(\"V426\",  # ICD-9-CM: Lung transplant status\n                                               \"Z942\")  # ICD-10-CM: Lung transplant status\ncomorbidity_ICD_list[[\"Pancreas transplant\"]]&lt;-  c(\"V4283\", # ICD-9-CM: Pancreas transplant status\n                                                   \"Z9483\") # ICD-10-CM: Pancreas transplant status\ncomorbidity_ICD_list[[\"Liver transplant\"]]&lt;-  c(\"V427\",  # ICD-9-CM: Liver transplant status\n                                                \"Z944\")  # ICD-10-CM: Liver transplant status\ncomorbidity_ICD_list[[\"Intestinal transplant\"]]&lt;-  c(\"V4284\", # ICD-9-CM: Intestinal transplant status\n                                                     \"Z9482\") # ICD-10-CM: Intestinal transplant status\n\ncomorbidity_ICD_list[[\"cirrhosis\"]]&lt;-c(\"5712\", # Alcoholic cirrhosis of liver\n                                       \"5715\", # Cirrhosis of liver without mention of alcohol\n                                       \"5716\", # Biliary cirrhosis\n                                       \"5722\", # Hepatic encephalopathy\n                                       \"5723\", # Portal hypertension\n                                       \"5724\", # Hepatorenal syndrome\n                                       \"5728\", #Other sequelae of chronic liver disease# \n                                       \"K7030\", # Alcoholic cirrhosis of liver with ascites\n                                       \"K7031\", # Alcoholic cirrhosis of liver without ascites\n                                       \"K7460\", # Unspecified cirrhosis of liver\n                                       \"K7469\", # Other cirrhosis of liver\n                                       \"K743\", # Primary biliary cirrhosis\n                                       \"K744\", # Secondary biliary cirrhosis\n                                       \"K745\", # Biliary cirrhosis, unspecified\n                                       \"K7290\", # Hepatic failure, unspecified \n                                       \"K7291\", # Acute and subacute hepatic failure with coma\n                                       \"K766\", # Portal hypertension\n                                       \"K767\") # Hepatorenal syndrome\n\ncomorbidity_ICD_list[[\"CMV\"]] &lt;- c(\n  \"0785\",   # Cytomegaloviral disease (ICD-9)\n  \"B250\",   # CMV pneumonitis\n  \"B251\",   # CMV hepatitis\n  \"B252\",   # CMV pancreatitis\n  \"B258\",   # Other CMV diseases\n  \"B259\",   # CMV disease, unspecified\n  \"B2710\",  # Cytomegaloviral mononucleosis without complication\n  \"B2711\"   # Cytomegaloviral mononucleosis with complication\n)\n\ncomorbidity_ICD_list[[\"Diabetes\"]]&lt;-c(\"25000\", \n                                      \"E0800\", \n                                      \"E0900\", \n                                      \"E1000\", \n                                      \"E1100\", \n                                      \"E1300\", \n                                      \"25001\", \n                                      \"E0801\", \n                                      \"E0901\", \n                                      \"E1001\", \n                                      \"E1101\", \n                                      \"E1301\", \n                                      \"25002\", \n                                      \"E0802\", \n                                      \"E0902\", \n                                      \"E1002\", \n                                      \"E1102\", \n                                      \"E1302\", \n                                      \"25003\", \n                                      \"E0803\", \n                                      \"E0903\", \n                                      \"E1003\", \n                                      \"E1103\", \n                                      \"E1303\", \n                                      \"25004\", \n                                      \"E0804\", \n                                      \"E0904\", \n                                      \"E1004\", \n                                      \"E1104\", \n                                      \"E1304\", \n                                      \"25005\", \n                                      \"E0805\", \n                                      \"E0905\", \n                                      \"E1005\", \n                                      \"E1105\", \n                                      \"E1305\", \n                                      \"25006\", \n                                      \"E0806\", \n                                      \"E0906\", \n                                      \"E1006\", \n                                      \"E1106\", \n                                      \"E1306\", \n                                      \"25007\", \n                                      \"E0807\", \n                                      \"E0907\", \n                                      \"E1007\", \n                                      \"E1107\", \n                                      \"E1307\", \n                                      \"25008\", \n                                      \"E0808\", \n                                      \"E0908\", \n                                      \"E1008\", \n                                      \"E1108\", \n                                      \"E1308\", \n                                      \"25009\", \n                                      \"E0809\", \n                                      \"E0909\", \n                                      \"E1009\", \n                                      \"E1109\", \n                                      \"E1309\", \n                                      \"25010\", \n                                      \"E0810\", \n                                      \"E0910\", \n                                      \"E1010\", \n                                      \"E1110\", \n                                      \"E1310\", \n                                      \"25011\", \n                                      \"E0811\", \n                                      \"E0911\", \n                                      \"E1011\", \n                                      \"E1111\", \n                                      \"E1311\", \n                                      \"25012\", \n                                      \"E0812\", \n                                      \"E0912\", \n                                      \"E1012\", \n                                      \"E1112\", \n                                      \"E1312\", \n                                      \"25013\", \n                                      \"E0813\", \n                                      \"E0913\", \n                                      \"E1013\", \n                                      \"E1113\", \n                                      \"E1313\", \n                                      \"25014\", \n                                      \"E0814\", \n                                      \"E0914\", \n                                      \"E1014\", \n                                      \"E1114\", \n                                      \"E1314\", \n                                      \"25015\", \n                                      \"E0815\", \n                                      \"E0915\", \n                                      \"E1015\", \n                                      \"E1115\", \n                                      \"E1315\", \n                                      \"25016\", \n                                      \"E0816\", \n                                      \"E0916\", \n                                      \"E1016\", \n                                      \"E1116\", \n                                      \"E1316\", \n                                      \"25017\", \n                                      \"E0817\", \n                                      \"E0917\", \n                                      \"E1017\", \n                                      \"E1117\", \n                                      \"E1317\", \n                                      \"25018\", \n                                      \"E0818\", \n                                      \"E0918\", \n                                      \"E1018\", \n                                      \"E1118\", \n                                      \"E1318\", \n                                      \"25019\", \n                                      \"E0819\", \n                                      \"E0919\", \n                                      \"E1019\", \n                                      \"E1119\", \n                                      \"E1319\", \n                                      \"25020\", \n                                      \"E0820\", \n                                      \"E0920\", \n                                      \"E1020\", \n                                      \"E1120\", \n                                      \"E1320\", \n                                      \"25021\", \n                                      \"E0821\", \n                                      \"E0921\", \n                                      \"E1021\", \n                                      \"E1121\", \n                                      \"E1321\", \n                                      \"25022\", \n                                      \"E0822\", \n                                      \"E0922\", \n                                      \"E1022\", \n                                      \"E1122\", \n                                      \"E1322\", \n                                      \"25023\", \n                                      \"E0823\", \n                                      \"E0923\", \n                                      \"E1023\", \n                                      \"E1123\", \n                                      \"E1323\", \n                                      \"25024\", \n                                      \"E0824\", \n                                      \"E0924\", \n                                      \"E1024\", \n                                      \"E1124\", \n                                      \"E1324\", \n                                      \"25025\", \n                                      \"E0825\", \n                                      \"E0925\", \n                                      \"E1025\", \n                                      \"E1125\", \n                                      \"E1325\", \n                                      \"25026\", \n                                      \"E0826\", \n                                      \"E0926\", \n                                      \"E1026\", \n                                      \"E1126\", \n                                      \"E1326\", \n                                      \"25027\", \n                                      \"E0827\", \n                                      \"E0927\", \n                                      \"E1027\", \n                                      \"E1127\", \n                                      \"E1327\", \n                                      \"25028\", \n                                      \"E0828\", \n                                      \"E0928\", \n                                      \"E1028\", \n                                      \"E1128\", \n                                      \"E1328\", \n                                      \"25029\", \n                                      \"E0829\", \n                                      \"E0929\", \n                                      \"E1029\", \n                                      \"E1129\", \n                                      \"E1329\", \n                                      \"25030\", \n                                      \"E0830\", \n                                      \"E0930\", \n                                      \"E1030\", \n                                      \"E1130\", \n                                      \"E1330\", \n                                      \"25031\", \n                                      \"E0831\", \n                                      \"E0931\", \n                                      \"E1031\", \n                                      \"E1131\", \n                                      \"E1331\", \n                                      \"25032\", \n                                      \"E0832\", \n                                      \"E0932\", \n                                      \"E1032\", \n                                      \"E1132\", \n                                      \"E1332\", \n                                      \"25033\", \n                                      \"E0833\", \n                                      \"E0933\", \n                                      \"E1033\", \n                                      \"E1133\", \n                                      \"E1333\", \n                                      \"25034\", \n                                      \"E0834\", \n                                      \"E0934\", \n                                      \"E1034\", \n                                      \"E1134\", \n                                      \"E1334\", \n                                      \"25035\", \n                                      \"E0835\", \n                                      \"E0935\", \n                                      \"E1035\", \n                                      \"E1135\", \n                                      \"E1335\", \n                                      \"25036\", \n                                      \"E0836\", \n                                      \"E0936\", \n                                      \"E1036\", \n                                      \"E1136\", \n                                      \"E1336\", \n                                      \"25037\", \n                                      \"E0837\", \n                                      \"E0937\", \n                                      \"E1037\", \n                                      \"E1137\", \n                                      \"E1337\", \n                                      \"25038\", \n                                      \"E0838\", \n                                      \"E0938\", \n                                      \"E1038\", \n                                      \"E1138\", \n                                      \"E1338\", \n                                      \"25039\", \n                                      \"E0839\", \n                                      \"E0939\", \n                                      \"E1039\", \n                                      \"E1139\", \n                                      \"E1339\", \n                                      \"25040\", \n                                      \"E0840\", \n                                      \"E0940\", \n                                      \"E1040\", \n                                      \"E1140\", \n                                      \"E1340\", \n                                      \"25041\", \n                                      \"E0841\", \n                                      \"E0941\", \n                                      \"E1041\", \n                                      \"E1141\", \n                                      \"E1341\", \n                                      \"25042\", \n                                      \"E0842\", \n                                      \"E0942\", \n                                      \"E1042\", \n                                      \"E1142\", \n                                      \"E1342\", \n                                      \"25043\", \n                                      \"E0843\", \n                                      \"E0943\", \n                                      \"E1043\", \n                                      \"E1143\", \n                                      \"E1343\", \n                                      \"25044\", \n                                      \"E0844\", \n                                      \"E0944\", \n                                      \"E1044\", \n                                      \"E1144\", \n                                      \"E1344\", \n                                      \"25045\", \n                                      \"E0845\", \n                                      \"E0945\", \n                                      \"E1045\", \n                                      \"E1145\", \n                                      \"E1345\", \n                                      \"25046\", \n                                      \"E0846\", \n                                      \"E0946\", \n                                      \"E1046\", \n                                      \"E1146\", \n                                      \"E1346\", \n                                      \"25047\", \n                                      \"E0847\", \n                                      \"E0947\", \n                                      \"E1047\", \n                                      \"E1147\", \n                                      \"E1347\", \n                                      \"25048\", \n                                      \"E0848\", \n                                      \"E0948\", \n                                      \"E1048\", \n                                      \"E1148\", \n                                      \"E1348\", \n                                      \"25049\", \n                                      \"E0849\", \n                                      \"E0949\", \n                                      \"E1049\", \n                                      \"E1149\", \n                                      \"E1349\", \n                                      \"25050\", \n                                      \"E0850\", \n                                      \"E0950\", \n                                      \"E1050\", \n                                      \"E1150\", \n                                      \"E1350\", \n                                      \"25051\", \n                                      \"E0851\", \n                                      \"E0951\", \n                                      \"E1051\", \n                                      \"E1151\", \n                                      \"E1351\", \n                                      \"25052\", \n                                      \"E0852\", \n                                      \"E0952\", \n                                      \"E1052\", \n                                      \"E1152\", \n                                      \"E1352\", \n                                      \"25053\", \n                                      \"E0853\", \n                                      \"E0953\", \n                                      \"E1053\", \n                                      \"E1153\", \n                                      \"E1353\", \n                                      \"25054\", \n                                      \"E0854\", \n                                      \"E0954\", \n                                      \"E1054\", \n                                      \"E1154\", \n                                      \"E1354\", \n                                      \"25055\", \n                                      \"E0855\", \n                                      \"E0955\", \n                                      \"E1055\", \n                                      \"E1155\", \n                                      \"E1355\", \n                                      \"25056\", \n                                      \"E0856\", \n                                      \"E0956\", \n                                      \"E1056\", \n                                      \"E1156\", \n                                      \"E1356\", \n                                      \"25057\", \n                                      \"E0857\", \n                                      \"E0957\", \n                                      \"E1057\", \n                                      \"E1157\", \n                                      \"E1357\", \n                                      \"25058\", \n                                      \"E0858\", \n                                      \"E0958\", \n                                      \"E1058\", \n                                      \"E1158\", \n                                      \"E1358\", \n                                      \"25059\", \n                                      \"E0859\", \n                                      \"E0959\", \n                                      \"E1059\", \n                                      \"E1159\", \n                                      \"E1359\", \n                                      \"25060\", \n                                      \"E0860\", \n                                      \"E0960\", \n                                      \"E1060\", \n                                      \"E1160\", \n                                      \"E1360\", \n                                      \"25061\", \n                                      \"E0861\", \n                                      \"E0961\", \n                                      \"E1061\", \n                                      \"E1161\", \n                                      \"E1361\", \n                                      \"25062\", \n                                      \"E0862\", \n                                      \"E0962\", \n                                      \"E1062\", \n                                      \"E1162\", \n                                      \"E1362\", \n                                      \"25063\", \n                                      \"E0863\", \n                                      \"E0963\", \n                                      \"E1063\", \n                                      \"E1163\", \n                                      \"E1363\", \n                                      \"25064\", \n                                      \"E0864\", \n                                      \"E0964\", \n                                      \"E1064\", \n                                      \"E1164\", \n                                      \"E1364\", \n                                      \"25065\", \n                                      \"E0865\", \n                                      \"E0965\", \n                                      \"E1065\", \n                                      \"E1165\", \n                                      \"E1365\", \n                                      \"25066\", \n                                      \"E0866\", \n                                      \"E0966\", \n                                      \"E1066\", \n                                      \"E1166\", \n                                      \"E1366\", \n                                      \"25067\", \n                                      \"E0867\", \n                                      \"E0967\", \n                                      \"E1067\", \n                                      \"E1167\", \n                                      \"E1367\", \n                                      \"25068\", \n                                      \"E0868\", \n                                      \"E0968\", \n                                      \"E1068\", \n                                      \"E1168\", \n                                      \"E1368\", \n                                      \"25069\", \n                                      \"E0869\", \n                                      \"E0969\", \n                                      \"E1069\", \n                                      \"E1169\", \n                                      \"E1369\", \n                                      \"25070\", \n                                      \"E0870\", \n                                      \"E0970\", \n                                      \"E1070\", \n                                      \"E1170\", \n                                      \"E1370\", \n                                      \"25071\", \n                                      \"E0871\", \n                                      \"E0971\", \n                                      \"E1071\", \n                                      \"E1171\", \n                                      \"E1371\", \n                                      \"25072\", \n                                      \"E0872\", \n                                      \"E0972\", \n                                      \"E1072\", \n                                      \"E1172\", \n                                      \"E1372\", \n                                      \"25073\", \n                                      \"E0873\", \n                                      \"E0973\", \n                                      \"E1073\", \n                                      \"E1173\", \n                                      \"E1373\", \n                                      \"25074\", \n                                      \"E0874\", \n                                      \"E0974\", \n                                      \"E1074\", \n                                      \"E1174\", \n                                      \"E1374\", \n                                      \"25075\", \n                                      \"E0875\", \n                                      \"E0975\", \n                                      \"E1075\", \n                                      \"E1175\", \n                                      \"E1375\", \n                                      \"25076\", \n                                      \"E0876\", \n                                      \"E0976\", \n                                      \"E1076\", \n                                      \"E1176\", \n                                      \"E1376\", \n                                      \"25077\", \n                                      \"E0877\", \n                                      \"E0977\", \n                                      \"E1077\", \n                                      \"E1177\", \n                                      \"E1377\", \n                                      \"25078\", \n                                      \"E0878\",\n                                      \"E0978\", \n                                      \"E1078\", \n                                      \"E1178\", \n                                      \"E1378\", \n                                      \"25079\", \n                                      \"E0879\", \n                                      \"E0979\", \n                                      \"E1079\", \n                                      \"E1179\", \n                                      \"E1379\", \n                                      \"25080\", \n                                      \"E0880\", \n                                      \"E0980\", \n                                      \"E1080\", \n                                      \"E1180\", \n                                      \"E1380\", \n                                      \"25081\", \n                                      \"E0881\", \n                                      \"E0981\", \n                                      \"E1081\", \n                                      \"E1181\", \n                                      \"E1381\", \n                                      \"25082\", \n                                      \"E0882\", \n                                      \"E0982\", \n                                      \"E1082\", \n                                      \"E1182\", \n                                      \"E1382\", \n                                      \"25083\", \n                                      \"E0883\", \n                                      \"E0983\", \n                                      \"E1083\", \n                                      \"E1183\", \n                                      \"E1383\", \n                                      \"25084\", \n                                      \"E0884\", \n                                      \"E0984\", \n                                      \"E1084\", \n                                      \"E1184\", \n                                      \"E1384\", \n                                      \"25085\", \n                                      \"E0885\", \n                                      \"E0985\", \n                                      \"E1085\", \n                                      \"E1185\", \n                                      \"E1385\", \n                                      \"25086\", \n                                      \"E0886\", \n                                      \"E0986\", \n                                      \"E1086\", \n                                      \"E1186\", \n                                      \"E1386\", \n                                      \"25087\", \n                                      \"E0887\", \n                                      \"E0987\", \n                                      \"E1087\", \n                                      \"E1187\", \n                                      \"E1387\", \n                                      \"25088\", \n                                      \"E0888\", \n                                      \"E0988\", \n                                      \"E1088\", \n                                      \"E1188\", \n                                      \"E1388\", \n                                      \"25089\", \n                                      \"E0889\", \n                                      \"E0989\", \n                                      \"E1089\", \n                                      \"E1189\", \n                                      \"E1389\", \n                                      \"25090\", \n                                      \"E0890\", \n                                      \"E0990\", \n                                      \"E1090\", \n                                      \"E1190\", \n                                      \"E1390\", \n                                      \"25091\", \n                                      \"E0891\", \n                                      \"E0991\", \n                                      \"E1091\", \n                                      \"E1191\", \n                                      \"E1391\", \n                                      \"25092\", \n                                      \"E0892\", \n                                      \"E0992\", \n                                      \"E1092\", \n                                      \"E1192\", \n                                      \"E1392\", \n                                      \"25093\", \n                                      \"E0893\", \n                                      \"E0993\", \n                                      \"E1093\", \n                                      \"E1193\", \n                                      \"E1393\", \n                                      \"25094\", \n                                      \"E0894\", \n                                      \"E0994\", \n                                      \"E1094\", \n                                      \"E1194\", \n                                      \"E1394\", \n                                      \"25095\", \n                                      \"E0895\", \n                                      \"E0995\", \n                                      \"E1095\", \n                                      \"E1195\", \n                                      \"E1395\", \n                                      \"25096\", \n                                      \"E0896\", \n                                      \"E0996\", \n                                      \"E1096\", \n                                      \"E1196\", \n                                      \"E1396\", \n                                      \"25097\", \n                                      \"E0897\", \n                                      \"E0997\", \n                                      \"E1097\", \n                                      \"E1197\", \n                                      \"E1397\", \n                                      \"25098\", \n                                      \"E0898\", \n                                      \"E0998\", \n                                      \"E1098\", \n                                      \"E1198\", \n                                      \"E1398\", \n                                      \"25099\", \n                                      \"E0899\", \n                                      \"E0999\", \n                                      \"E1099\", \n                                      \"E1199\", \n                                      \"E1399\", \n                                      \"250\", \n                                      \"E08\", \n                                      \"E09\", \n                                      \"E10\", \n                                      \"E11\", \n                                      \"E13\", \n                                      \"3572\", \n                                      \"36202\", \n                                      \"3620\", \n                                      \"36641\", \n                                      \"E08\", \n                                      \"E09\", \n                                      \"E10\", \n                                      \"E11\", \n                                      \"E13\", \n                                      \"2500\", \n                                      \"2501\", \n                                      \"2502\", \n                                      \"2503\", \n                                      \"2504\", \n                                      \"2505\", \n                                      \"2506\", \n                                      \"2507\", \n                                      \"2508\", \n                                      \"2509\", \n                                      \"E080\", \n                                      \"E081\", \n                                      \"E082\", \n                                      \"E083\", \n                                      \"E084\", \n                                      \"E085\", \n                                      \"E086\", \n                                      \"E087\", \n                                      \"E088\", \n                                      \"E089\", \n                                      \"E090\", \n                                      \"E091\", \n                                      \"E092\", \n                                      \"E093\", \n                                      \"E094\", \n                                      \"E095\", \n                                      \"E096\", \n                                      \"E097\", \n                                      \"E098\", \n                                      \"E099\", \n                                      \"E100\", \n                                      \"E101\", \n                                      \"E102\", \n                                      \"E103\", \n                                      \"E104\", \n                                      \"E105\", \n                                      \"E106\", \n                                      \"E107\", \n                                      \"E108\", \n                                      \"E109\", \n                                      \"E110\", \n                                      \"E111\", \n                                      \"E112\", \n                                      \"E113\", \n                                      \"E114\", \n                                      \"E115\", \n                                      \"E116\", \n                                      \"E117\", \n                                      \"E118\", \n                                      \"E119\", \n                                      \"E130\", \n                                      \"E131\", \n                                      \"E132\", \n                                      \"E133\", \n                                      \"E134\", \n                                      \"E135\", \n                                      \"E136\", \n                                      \"E137\", \n                                      \"E138\",\n                                      \"E139\")\n\n\n\n\n\n\n\n\n\n\nICD-9 and ICD-10 Codes Used to Define Comorbidities\n\n\nCodes grouped by clinical condition\n\n\nComorbidity\nICD Codes\n\n\n\n\ncryptococcus\n1175, 3210, B450, B451, B452, B453, B457, B458, B459, B45\n\n\nHIV\n042, 07953, V08, 79571, B20, Z21\n\n\nHeart transplant\nV421, Z941\n\n\nHeart-lung transplant\nZ943\n\n\nLung transplant\nV426, Z942\n\n\nPancreas transplant\nV4283, Z9483\n\n\nLiver transplant\nV427, Z944\n\n\nIntestinal transplant\nV4284, Z9482\n\n\ncirrhosis\n5712, 5715, 5716, 5722, 5723, 5724, 5728, K7030, K7031, K7460, K7469, K743, K744, K745, K7290, K7291, K766, K767\n\n\nCMV\n0785, B250, B251, B252, B258, B259, B2710, B2711\n\n\nDiabetes\n25000, E0800, E0900, E1000, E1100, E1300, 25001, E0801, E0901, E1001, E1101, E1301, 25002, E0802, E0902, E1002, E1102, E1302, 25003, E0803, E0903, E1003, E1103, E1303, 25004, E0804, E0904, E1004, E1104, E1304, 25005, E0805, E0905, E1005, E1105, E1305, 25006, E0806, E0906, E1006, E1106, E1306, 25007, E0807, E0907, E1007, E1107, E1307, 25008, E0808, E0908, E1008, E1108, E1308, 25009, E0809, E0909, E1009, E1109, E1309, 25010, E0810, E0910, E1010, E1110, E1310, 25011, E0811, E0911, E1011, E1111, E1311, 25012, E0812, E0912, E1012, E1112, E1312, 25013, E0813, E0913, E1013, E1113, E1313, 25014, E0814, E0914, E1014, E1114, E1314, 25015, E0815, E0915, E1015, E1115, E1315, 25016, E0816, E0916, E1016, E1116, E1316, 25017, E0817, E0917, E1017, E1117, E1317, 25018, E0818, E0918, E1018, E1118, E1318, 25019, E0819, E0919, E1019, E1119, E1319, 25020, E0820, E0920, E1020, E1120, E1320, 25021, E0821, E0921, E1021, E1121, E1321, 25022, E0822, E0922, E1022, E1122, E1322, 25023, E0823, E0923, E1023, E1123, E1323, 25024, E0824, E0924, E1024, E1124, E1324, 25025, E0825, E0925, E1025, E1125, E1325, 25026, E0826, E0926, E1026, E1126, E1326, 25027, E0827, E0927, E1027, E1127, E1327, 25028, E0828, E0928, E1028, E1128, E1328, 25029, E0829, E0929, E1029, E1129, E1329, 25030, E0830, E0930, E1030, E1130, E1330, 25031, E0831, E0931, E1031, E1131, E1331, 25032, E0832, E0932, E1032, E1132, E1332, 25033, E0833, E0933, E1033, E1133, E1333, 25034, E0834, E0934, E1034, E1134, E1334, 25035, E0835, E0935, E1035, E1135, E1335, 25036, E0836, E0936, E1036, E1136, E1336, 25037, E0837, E0937, E1037, E1137, E1337, 25038, E0838, E0938, E1038, E1138, E1338, 25039, E0839, E0939, E1039, E1139, E1339, 25040, E0840, E0940, E1040, E1140, E1340, 25041, E0841, E0941, E1041, E1141, E1341, 25042, E0842, E0942, E1042, E1142, E1342, 25043, E0843, E0943, E1043, E1143, E1343, 25044, E0844, E0944, E1044, E1144, E1344, 25045, E0845, E0945, E1045, E1145, E1345, 25046, E0846, E0946, E1046, E1146, E1346, 25047, E0847, E0947, E1047, E1147, E1347, 25048, E0848, E0948, E1048, E1148, E1348, 25049, E0849, E0949, E1049, E1149, E1349, 25050, E0850, E0950, E1050, E1150, E1350, 25051, E0851, E0951, E1051, E1151, E1351, 25052, E0852, E0952, E1052, E1152, E1352, 25053, E0853, E0953, E1053, E1153, E1353, 25054, E0854, E0954, E1054, E1154, E1354, 25055, E0855, E0955, E1055, E1155, E1355, 25056, E0856, E0956, E1056, E1156, E1356, 25057, E0857, E0957, E1057, E1157, E1357, 25058, E0858, E0958, E1058, E1158, E1358, 25059, E0859, E0959, E1059, E1159, E1359, 25060, E0860, E0960, E1060, E1160, E1360, 25061, E0861, E0961, E1061, E1161, E1361, 25062, E0862, E0962, E1062, E1162, E1362, 25063, E0863, E0963, E1063, E1163, E1363, 25064, E0864, E0964, E1064, E1164, E1364, 25065, E0865, E0965, E1065, E1165, E1365, 25066, E0866, E0966, E1066, E1166, E1366, 25067, E0867, E0967, E1067, E1167, E1367, 25068, E0868, E0968, E1068, E1168, E1368, 25069, E0869, E0969, E1069, E1169, E1369, 25070, E0870, E0970, E1070, E1170, E1370, 25071, E0871, E0971, E1071, E1171, E1371, 25072, E0872, E0972, E1072, E1172, E1372, 25073, E0873, E0973, E1073, E1173, E1373, 25074, E0874, E0974, E1074, E1174, E1374, 25075, E0875, E0975, E1075, E1175, E1375, 25076, E0876, E0976, E1076, E1176, E1376, 25077, E0877, E0977, E1077, E1177, E1377, 25078, E0878, E0978, E1078, E1178, E1378, 25079, E0879, E0979, E1079, E1179, E1379, 25080, E0880, E0980, E1080, E1180, E1380, 25081, E0881, E0981, E1081, E1181, E1381, 25082, E0882, E0982, E1082, E1182, E1382, 25083, E0883, E0983, E1083, E1183, E1383, 25084, E0884, E0984, E1084, E1184, E1384, 25085, E0885, E0985, E1085, E1185, E1385, 25086, E0886, E0986, E1086, E1186, E1386, 25087, E0887, E0987, E1087, E1187, E1387, 25088, E0888, E0988, E1088, E1188, E1388, 25089, E0889, E0989, E1089, E1189, E1389, 25090, E0890, E0990, E1090, E1190, E1390, 25091, E0891, E0991, E1091, E1191, E1391, 25092, E0892, E0992, E1092, E1192, E1392, 25093, E0893, E0993, E1093, E1193, E1393, 25094, E0894, E0994, E1094, E1194, E1394, 25095, E0895, E0995, E1095, E1195, E1395, 25096, E0896, E0996, E1096, E1196, E1396, 25097, E0897, E0997, E1097, E1197, E1397, 25098, E0898, E0998, E1098, E1198, E1398, 25099, E0899, E0999, E1099, E1199, E1399, 250, E08, E09, E10, E11, E13, 3572, 36202, 3620, 36641, E08, E09, E10, E11, E13, 2500, 2501, 2502, 2503, 2504, 2505, 2506, 2507, 2508, 2509, E080, E081, E082, E083, E084, E085, E086, E087, E088, E089, E090, E091, E092, E093, E094, E095, E096, E097, E098, E099, E100, E101, E102, E103, E104, E105, E106, E107, E108, E109, E110, E111, E112, E113, E114, E115, E116, E117, E118, E119, E130, E131, E132, E133, E134, E135, E136, E137, E138, E139"
  },
  {
    "objectID": "quarto/setup.html#other-portions-of-the-analysis",
    "href": "quarto/setup.html#other-portions-of-the-analysis",
    "title": "Create cohort",
    "section": "Other portions of the analysis",
    "text": "Other portions of the analysis\n\nAbout: methods, assumptions, and disclosures"
  },
  {
    "objectID": "quarto/postmatch_processing.html",
    "href": "quarto/postmatch_processing.html",
    "title": "Post-match processing",
    "section": "",
    "text": "The code in this script adds the cost data to the dataset and prepares for modeling"
  },
  {
    "objectID": "quarto/postmatch_processing.html#create-cohort",
    "href": "quarto/postmatch_processing.html#create-cohort",
    "title": "Create cohort",
    "section": "",
    "text": "The code in this script creates the cohort of kidney transplant patients eligible for the study\n\n\n\n\n\n\nSource code\n\n\n\nThe full R script is available at:\n\nR/create_cohort.R\n\nThis R script file is itself reliant on the following helper files:\n\nR/setup.R\nR/functions.R"
  },
  {
    "objectID": "quarto/postmatch_processing.html#section",
    "href": "quarto/postmatch_processing.html#section",
    "title": "Create cohort",
    "section": "",
    "text": "Code\n#Create a cohort of kidney transplant patients with cryptococcus matched to controls without cryptococcus\n\nsource(\"R/setup.R\")\n\n#Import core demographics from \"patients\" file\npatients_raw&lt;-usRds::load_usrds_file(\"patients\")%&gt;%\n  select(-ZIPCODE) #This is ZIP code at time of USRDS initiation, but we want at time of crypto dx\n\n#Import key information about the transplants from the TX and UNOS databases\ntx_raw&lt;-usRds::load_usrds_file(\"tx\")%&gt;%\n  select(USRDS_ID, TDATE, FAILDATE, TRR_ID_CODE)\n\nki_raw&lt;-usRds::load_usrds_file(\"txunos_trr_ki\")%&gt;%\n  select(USRDS_ID, ORGTYP, HRTX, LUTX, INTX, LITX,PITX,BMTX, TRR_ID_CODE)\n\nkp_raw&lt;-usRds::load_usrds_file(\"txunos_trr_kp\")%&gt;%\n  select(USRDS_ID, ORGTYP, HRTX, LUTX, INTX, LITX,PITX,BMTX, TRR_ID_CODE)\n\n#This combines the three datasets\ntx_clean&lt;-tx_raw%&gt;%\n  left_join(bind_rows(ki_raw,\n                      kp_raw))%&gt;%\n  arrange(USRDS_ID, TDATE)%&gt;%\n  \n  group_by(USRDS_ID)%&gt;%\n  mutate(cumulative_transplant_total=row_number())%&gt;%\n  ungroup\n\n#Create a time-varying dataset that can be used to track whether a pt has an active or inactive graft and the cumulative number of txs\ntx_status&lt;-tx_clean%&gt;%\n  select(USRDS_ID, TDATE, FAILDATE, cumulative_transplant_total)%&gt;%\n  pivot_longer(\n    cols = c(TDATE, FAILDATE),\n    names_to = \"event_type\",\n    values_to = \"event_date\"\n  ) %&gt;%\n  filter(!is.na(event_date)) %&gt;%\n  mutate(\n    graft_status = case_when(\n      event_type == \"TDATE\" ~ \"Active\",\n      event_type == \"FAILDATE\" ~ \"Failed\"\n    )\n  ) %&gt;%\n  select(-event_type)%&gt;%\n  arrange(USRDS_ID, cumulative_transplant_total, event_date, graft_status)\n\n\n#Initialize a flowchart cohort\npatients_clean&lt;-patients_raw%&gt;%\n  as_fc(label=\"Patients in USRDS\")%&gt;%\n  \n  \n  fc_filter(TOTTX&gt;0, \n            label=\"Prior transplant\", \n            label_exc = \"Excluded: No prior transplant\", \n            show_exc = TRUE)%&gt;%\n  \n  fc_filter(TX1DATE&lt;as.Date(\"2021-01-01\"), \n            label=\"Transplant prior to 2021\", \n            label_exc = \"Excluded: Transplant 2021 or later\", \n            show_exc = TRUE)\n\n\n\n#Create list of USRDS ids for patients who have undergone transplant\ntransplant_id_list&lt;-patients_clean$data%&gt;%\n  pull(USRDS_ID)\n\n# We now seek to determine comorbidities by using diagnosis codes from the setup.R file\n\ncomorbidity_diagnosis_date&lt;-list()\n\n# Combine all ICD codes from all comorbidities into one list \ncomorbidity_ICD_combined_list&lt;-unlist(comorbidity_ICD_list, use.names=FALSE)\n\n#Scrape files for any comorbidity claim\ncomorbidity_claims_df&lt;-bind_rows(get_IN_ICD(icd_codes = comorbidity_ICD_combined_list, \n                                            years = 2006:2021, \n                                            usrds_ids = transplant_id_list ),\n                                 get_PS_ICD(icd_codes = comorbidity_ICD_combined_list, \n                                            years = 2006:2021, \n                                            usrds_ids = transplant_id_list )%&gt;%rename(CODE=DIAG))%&gt;%\n  arrange(USRDS_ID, CLM_FROM)\n\n#Create comorbidity_diagnosis_date data frame\nfor (comorbidity in names(comorbidity_ICD_list)){\n  \n  comorbidity_diagnosis_date[[comorbidity]]&lt;-comorbidity_claims_df%&gt;%\n    filter(CODE %in% comorbidity_ICD_list[[comorbidity]])%&gt;%\n    establish_dx_date(diagnosis_established = comorbidity)\n}\n\n#Load Medicare coverage history for all patients with transplant\nmedicare_history&lt;-load_usrds_file(\"payhist\",\n                                  usrds_ids = transplant_id_list)%&gt;%\n  arrange(USRDS_ID, BEGDATE)%&gt;%\n  group_by(USRDS_ID)%&gt;%\n  mutate(lag_ENDDATE=lag(ENDDATE))%&gt;%\n  mutate(gap=as.numeric(BEGDATE-lag_ENDDATE))%&gt;%\n  arrange(desc(gap))\n\n#Confirm no gaps (gap should always be 1 or missing)\nif (any(!is.na(medicare_history$gap) & medicare_history$gap != 1)) {\n  stop(\"Gap assumption violated: `gap` contains values other than 1 or NA.\")\n}\n\n#Add cryptococcus diagnosis date to patients_clean$data\n#First, format a df with the cryptococcus dx\ncryptococcus_df&lt;-comorbidity_diagnosis_date$cryptococcus%&gt;%\n  select(-diagnosis)%&gt;%\n  rename(cryptococcus_dx_date=date_established)\n\n\n\n#Join cryptococcus date to fc cohort\npatients_clean$data&lt;-left_join(patients_clean$data, \n                               cryptococcus_df)%&gt;%\n  mutate(cryptococcus_case=ifelse(is.na(cryptococcus_dx_date), \"Potential control\", \"Case\"))\n\n#Continue to create analytic cohort\npatients_merged&lt;-patients_clean%&gt;%\n  \n  #Remove patients with a diagnosis of cryptococcus prior to transplant\n  fc_filter(cryptococcus_dx_date&gt;TX1DATE | is.na(cryptococcus_dx_date), \n            label=\"No cryptococcus dx prior to transplant\", \n            label_exc = \"Excluded: cryptococcus dx prior to transplant\", \n            show_exc = TRUE)%&gt;%\n  \n  fc_filter((time_length(interval(BORN, cryptococcus_dx_date), \"years\") &gt;= 18) | is.na(cryptococcus_dx_date),\n            label=\"Age 18+ at time of cryptococcus if cryptococcus patient\", \n            label_exc = \"Excluded: First cryptococcus prior to age 18\", \n            show_exc = TRUE)%&gt;%\n  \n  fc_filter((year(cryptococcus_dx_date)&gt;=2007 & year(cryptococcus_dx_date)&lt;=2020) | is.na(cryptococcus_dx_date),\n            label=\"Incident cryptococcus between 1/1/2007 and 12/31/2020\", \n            label_exc = \"Incident cryptococcus outside of specified date range\", \n            show_exc = TRUE)%&gt;%\n  \n  #Split cohorts\n  fc_split(cryptococcus_case)\n  \n  #Check Medicare coverage for 365-day lookback period from day of first episode of cryptococcus\npatients_merged$data&lt;-patients_merged$data%&gt;%\n  verify_medicare_primary(index_date = \"cryptococcus_dx_date\",\n                          lookback_days = 365,\n                          coverage_start_variable = \"coverage_start_date\",\n                          coverage_end_variable = \"coverage_end_date\"\n                          )%&gt;%\n  mutate(medicare_primary_TF=ifelse(cryptococcus_case==\"Potential control\", TRUE, medicare_primary_TF))\n  \npatients_merged2&lt;-patients_merged%&gt;%\n  \n  fc_filter(medicare_primary_TF==TRUE, \n            label = \"365+ days of Medicare primary coverage\\nprior to first cryptococcus claim\", \n            label_exc = \"Excluded: Fewer than 365 days of coverage\",\n            show_exc = TRUE)\n\npatients_merged2$data&lt;-patients_merged2$data%&gt;%\n  select(-medicare_primary_TF)%&gt;%\n  \n  #Prepare data for cohort initialization\n  mutate(terminal_date=coalesce(coverage_end_date, censor_date))\n\npatients_merged2&lt;-patients_merged2%&gt;%\n  fc_filter((terminal_date - cryptococcus_dx_date &gt;=minimum_followup) | is.na(cryptococcus_dx_date), \n            label = \"Minimum followup exceeded\", \n            label_exc= \"Excluded: Minimum follow-up threshold not met\",\n            show_exc = TRUE)\n\n  \npatients_merged2%&gt;%\n  fc_draw()\n\n\n#Now we need to construct the time-varying data set\n\n#Ungroup\ninitial_cohort&lt;-patients_merged2$data%&gt;%\n  ungroup()%&gt;%\n\n#Cases join when they experience cryptococcus\n#Controls start on date of first transplant\n  mutate(\n    cohort_join_date = coalesce(\n      as.Date(cryptococcus_dx_date),\n      as.Date(TX1DATE)\n    )\n  )\n\n#Initialize cohort\nprematching_cohort&lt;-create_usrds_cohort(df=initial_cohort,\n                            start_date = \"cohort_join_date\",\n                            end_date = \"terminal_date\")%&gt;%\n  \n  # Add cirrhosis\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"cirrhosis\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"cirrhosis\")%&gt;%\n  \n  # Add CMV\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"CMV\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"CMV\")%&gt;%\n  \n  # Add diabetes\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Diabetes\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"diabetes\")%&gt;%\n  \n  # Add HIV\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"HIV\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"HIV\")%&gt;%\n  \n  # Add liver transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Liver transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"liver_transplant\")%&gt;%\n  \n  # Add lung transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Lung transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"lung_transplant\")%&gt;%\n  \n  # Add heart transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Heart transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"heart_transplant\")%&gt;%\n  \n  # Add pancreas transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Pancreas transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"pancreas_transplant\")%&gt;%\n  \n  # Add heart-lung transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Heart-lung transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"heartlung_transplant\")%&gt;%\n  \n  # Add intestinal transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Intestinal transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"intestinal_transplant\")%&gt;%\n  \n  #Add time-varying information about transplant status\n  add_cohort_covariate(covariate_data_frame=tx_status,\n                       covariate_date=\"event_date\",\n                       covariate_variable_name=\"cumulative_transplant_total\",\n                       covariate_value = \"cumulative_transplant_total\")%&gt;%\n  \n  #Add time-varying information about transplant status (whether current graft is active or failed)\n  add_cohort_covariate(covariate_data_frame=tx_status,\n                       covariate_date=\"event_date\",\n                       covariate_variable_name=\"current_graft_status\",\n                       covariate_value = \"graft_status\")%&gt;%\n  \n  #Add time-varying information about transplant status (date of most recent transplant)\n  add_cohort_covariate(covariate_data_frame=tx_status%&gt;%filter(graft_status==\"Active\"),\n                       covariate_date=\"event_date\",\n                       covariate_variable_name=\"most_recent_transplant_date\",\n                       covariate_value = \"event_date\")%&gt;%\n  \n  #Add time-varying information about transplant status (date of most recent graft failure)\n  add_cohort_covariate(covariate_data_frame=tx_status%&gt;%filter(graft_status==\"Failed\"),\n                       covariate_date=\"event_date\",\n                       covariate_variable_name=\"most_recent_failure_date\",\n                       covariate_value = \"event_date\")%&gt;%\n  \n  # Add Medicare current coverage\n  add_cohort_covariate(covariate_data_frame=medicare_history,\n                       covariate_date=\"BEGDATE\",\n                       covariate_variable_name=\"current_medicare_coverage\",\n                       covariate_value = \"PAYER\"\n                       )%&gt;%\n  \n  finalize_usrds_cohort(baseline_date_variable = \"most_recent_transplant_date\")"
  },
  {
    "objectID": "quarto/postmatch_processing.html#other-portions-of-the-analysis",
    "href": "quarto/postmatch_processing.html#other-portions-of-the-analysis",
    "title": "Post-match processing",
    "section": "Other portions of the analysis",
    "text": "Other portions of the analysis\n\nAbout: methods, assumptions, and disclosures"
  },
  {
    "objectID": "quarto/execute_matching.html",
    "href": "quarto/execute_matching.html",
    "title": "Execute matching",
    "section": "",
    "text": "The code in this script uses the cohort of kidney transplant patients with and without cryptococcosis developed in the R/create_cohort.R and executes n:1 matching based on a custom-written greedy algorithm\nCharacteristics of the matching algorithm:\n\nMatching without replacement: Each patient without cryptococcosis only serves as a control to one case at most. This makes subsequent statistical analysis simpler.\nRisk set sampling (incidence density sampling): If a case patient develops cryptococcosis at 243 days after their most recent kidney transplant, then all potential controls are chosen based on their covariate values at exactly 243 days post-transplant.\nGreedy matching: Cases are ranked by the number of potential controls at the onset, and then matches chosen without replacement without subsequent reordering.\nMix of exact matching** and caliper matching\n\nExact matching on the following:\n\nCirrhosis\nHIV\nDiabetes\n\nCaliper matching on the following:\n\nAge (within 10 years on the index date, calculated exactly)\nIndex date of case and controls (within 3 years of each other)\n\nPreferential matching on the following:\n\nNumber of transplants prior to index date\n\n\n\n\n\n\n\n\n\nSource code\n\n\n\nThe full R script is available at:\n\nR/execute_matching.R\n\nThis R script file is itself reliant on the following helper files:\n\nR/setup.R\nR/functions.R\n\n\n\n\n\nThe following code prepares the cohort for matching by creating a list object unmatched_patients, keeping only the initial row for each case as only the covariates at the time of cryptococcus are necessary for matching.\n\n\nCode\nunmatched_patients&lt;-list()\n\nunmatched_patients[[\"Case\"]]&lt;-prematching_cohort%&gt;%\n  filter(cryptococcus_case==\"Case\")\n\nunmatched_patients[[\"Control\"]]&lt;-prematching_cohort%&gt;%\n  filter(cryptococcus_case==\"Potential control\")\n\nunmatched_patients[[\"Case\"]]&lt;-unmatched_patients[[\"Case\"]]%&gt;%\n  group_by(USRDS_ID)%&gt;%\n  slice(1)%&gt;%\n  ungroup()\n\n#For exploration--perhaps can delete in future?\nCase&lt;-unmatched_patients[[\"Case\"]]\nControl&lt;-unmatched_patients[[\"Control\"]]\n\n\n\n\n\nThis step uses the calculate_number_potential_matches() function defined in the R/functions.R to add a column to the cases data set, then sorts the cases so that those with the lowest number of potential matches are matched first.\n(Note the following code took ~2 hours to execute on a laptop given the size of the dataset.)\n\n\nCode\n#Add number of potential control matches to Case df\nunmatched_patients[[\"Case\"]] &lt;- unmatched_patients[[\"Case\"]] %&gt;%\n  mutate(\n    num_potential_controls = pmap_int(\n      list(USRDS_ID, BORN,cirrhosis, CMV, HIV, diabetes, cryptococcus_dx_date, tstart),\n      function(USRDS_ID, BORN, cirrhosis, CMV, HIV, diabetes, matching_date, tstart) {\n        calculate_number_potential_matches(\n          unmatched_patients[[\"Control\"]],\n          USRDS_ID,\n          BORN, \n          cirrhosis,\n          CMV,\n          HIV,\n          diabetes,\n          matching_date,\n          tstart\n        )\n      }\n    )\n  )\n\n#Sort by number of potential matches so that most difficult to match cases are matched first\n#Set the index_date for cases to be the date of cryptococcus dx\nunmatched_patients[[\"Case\"]] &lt;- unmatched_patients[[\"Case\"]] %&gt;%\n  arrange(num_potential_controls)%&gt;%\n  mutate(index_date_match=cryptococcus_dx_date)\n\n\n#Can be deleted\nunmatched_patients_backup&lt;-unmatched_patients\nunmatched_patients&lt;-unmatched_patients_backup\n\n\n\n\n\nThe following code executes the match, creating a matched dataframe suitable for use in subsequent analysis.\n\n\nCode\n#Time to set up the matching loop\n\n#Initial the loop control\ncontinue&lt;-TRUE\ni&lt;-0\nset.seed(12345)\n\n#Initialize the object where the matched cases and controls will be stored\nmatched_patients&lt;-list()\nmatched_patients[[\"Case\"]]&lt;-unmatched_patients[[\"Case\"]][0, ]%&gt;%\n  mutate(matched_control_indices = list())\nmatched_patients[[\"Control\"]] &lt;- unmatched_patients[[\"Control\"]][0, ] %&gt;%\n  mutate(index_date_match = as.Date(character()))\n\n\n#Perform the match\nwhile (continue==TRUE)\n{\n  i&lt;-i+1\n  print(i)\n\n  #Select matches from controls\n  eligible_controls &lt;-unmatched_patients[[\"Control\"]]%&gt;%\n    \n    filter(cirrhosis==unmatched_patients$Case$cirrhosis[[1]])%&gt;%\n    #filter(CMV==unmatched_patients$Case$CMV[[1]])%&gt;%\n    filter(HIV==unmatched_patients$Case$HIV[[1]])%&gt;%\n    filter(diabetes==unmatched_patients$Case$diabetes[[1]])%&gt;%\n    \n    #Risk set matching\n    filter(tstart&lt;=unmatched_patients$Case$tstart[[1]])%&gt;%\n    filter(tstop&gt;unmatched_patients$Case$tstart[[1]])%&gt;%\n    \n    #Calculate date for age calculations/etc.\n    mutate(.baseline_control_date=unmatched_patients$Case$tstart[[1]] + most_recent_transplant_date)%&gt;%\n    \n    #Make sure case and control are sampled within 3 years of each other\n    filter(abs(time_length(interval(.baseline_control_date, unmatched_patients$Case$cryptococcus_dx_date[[1]]), \"years\")) &lt;=3)%&gt;%\n    \n    #filter(cohort_start_date&lt;=unmatched_patients$Case$cryptococcus_dx_date[[1]])%&gt;%\n    #filter(cohort_stop_date&gt;unmatched_patients$Case$cryptococcus_dx_date[[1]])%&gt;%\n    \n    #Age&gt;=18 on index date\n    filter(time_length(interval(BORN, .baseline_control_date), \"years\") &gt;= 18)%&gt;%\n    \n    #Age difference under 10 years, calculated at sampling date\n    filter(abs(time_length(interval(BORN,.baseline_control_date), \"years\")-\n                 time_length(interval(unmatched_patients$Case$BORN[[1]],\n                                      unmatched_patients$Case$cryptococcus_dx_date[[1]]), \"years\")) &lt;=10)%&gt;%\n  \n    verify_medicare_primary(index_date = \".baseline_control_date\", \n                            medicare_coverage_df = medicare_history, \n                            coverage_start_variable = \"medicare_coverage_start_date\",\n                            coverage_end_variable = \"medicare_coverage_end_date\",\n                            cache=TRUE)%&gt;%\n    filter(medicare_primary_TF==TRUE)%&gt;%\n    \n    #Move matches for cumulative number of transplants to the top\n    #Note: this step could be used for propensity score matching on various variables\n    #Consider minimizing date difference and age difference as well\n    arrange(desc(cumulative_transplant_total==unmatched_patients$Case$cumulative_transplant_total[[1]]))\n  \n  \n  #Number of controls is minimum of global constant number_controls_per_case and number of distinct USRDS_IDs\n  k &lt;- min(number_controls_per_case, nrow(distinct(eligible_controls, USRDS_ID)))\n  \n  #Initialize sampled_controls df\n  sampled_controls&lt;-eligible_controls[0, ]\n    \n  #Loop to select controls one at a time to ensure same patient is not sampled multiple times \n  while (k&gt;0)\n  {\n  \n  sampled_controls &lt;- bind_rows(\n    sampled_controls,\n    eligible_controls %&gt;%slice_head(n = 1))\n    \n    eligible_controls&lt;-eligible_controls%&gt;%\n      filter(!(USRDS_ID %in% sampled_controls$USRDS_ID ))\n\n    k&lt;-min(k-1, nrow(distinct(eligible_controls, USRDS_ID)))   \n  }\n    \n    sampled_controls&lt;-sampled_controls%&gt;%\n    mutate(index_date_match = .baseline_control_date)%&gt;%\n    select(-.baseline_control_date)\n  \n  #Add case to matched DF\n  matched_patients[[\"Case\"]]&lt;-unmatched_patients$Case[1,]%&gt;%\n    mutate(matched_control_indices=list(sampled_controls$USRDS_ID))%&gt;%\n    bind_rows(matched_patients[[\"Case\"]])\n  \n  #Add controls to control DF\n  matched_patients[[\"Control\"]]&lt;-matched_patients[[\"Control\"]]%&gt;%\n    bind_rows(sampled_controls)\n  \n  #Remove controls\n  unmatched_patients[[\"Control\"]]&lt;-unmatched_patients[[\"Control\"]]%&gt;%\n    filter(!(USRDS_ID %in% sampled_controls$USRDS_ID ))\n  \n  #Remove cases\n  unmatched_patients[[\"Case\"]]&lt;-unmatched_patients[[\"Case\"]]%&gt;%\n    slice(-1)\n  \n if (nrow(unmatched_patients[[\"Case\"]])==0){\n   continue&lt;-FALSE\n } \n  \n  if (i==10000){\n    continue&lt;-FALSE\n  }\n  \n}\n\n\npost_match_results&lt;-matched_patients%&gt;%\n  bind_rows(.id = \"patient_type\")\n\n\nThe modeling script uses the above matched dataframe for the actual cost analysis.\n\n\n\n\nSetup\nAbout: methods, assumptions, and disclosures"
  },
  {
    "objectID": "quarto/execute_matching.html#create-cohort",
    "href": "quarto/execute_matching.html#create-cohort",
    "title": "Create cohort",
    "section": "",
    "text": "The code in this script creates the cohort of kidney transplant patients eligible for the study\n\n\n\n\n\n\nSource code\n\n\n\nThe full R script is available at:\n\nR/create_cohort.R\n\nThis R script file is itself reliant on the following helper files:\n\nR/setup.R\nR/functions.R"
  },
  {
    "objectID": "quarto/execute_matching.html#section",
    "href": "quarto/execute_matching.html#section",
    "title": "Create cohort",
    "section": "",
    "text": "Code\n#Create a cohort of kidney transplant patients with cryptococcus matched to controls without cryptococcus\n\nsource(\"R/setup.R\")\n\n#Import core demographics from \"patients\" file\npatients_raw&lt;-usRds::load_usrds_file(\"patients\")%&gt;%\n  select(-ZIPCODE) #This is ZIP code at time of USRDS initiation, but we want at time of crypto dx\n\n#Import key information about the transplants from the TX and UNOS databases\ntx_raw&lt;-usRds::load_usrds_file(\"tx\")%&gt;%\n  select(USRDS_ID, TDATE, FAILDATE, TRR_ID_CODE)\n\nki_raw&lt;-usRds::load_usrds_file(\"txunos_trr_ki\")%&gt;%\n  select(USRDS_ID, ORGTYP, HRTX, LUTX, INTX, LITX,PITX,BMTX, TRR_ID_CODE)\n\nkp_raw&lt;-usRds::load_usrds_file(\"txunos_trr_kp\")%&gt;%\n  select(USRDS_ID, ORGTYP, HRTX, LUTX, INTX, LITX,PITX,BMTX, TRR_ID_CODE)\n\n#This combines the three datasets\ntx_clean&lt;-tx_raw%&gt;%\n  left_join(bind_rows(ki_raw,\n                      kp_raw))%&gt;%\n  arrange(USRDS_ID, TDATE)%&gt;%\n  \n  group_by(USRDS_ID)%&gt;%\n  mutate(cumulative_transplant_total=row_number())%&gt;%\n  ungroup\n\n#Create a time-varying dataset that can be used to track whether a pt has an active or inactive graft and the cumulative number of txs\ntx_status&lt;-tx_clean%&gt;%\n  select(USRDS_ID, TDATE, FAILDATE, cumulative_transplant_total)%&gt;%\n  pivot_longer(\n    cols = c(TDATE, FAILDATE),\n    names_to = \"event_type\",\n    values_to = \"event_date\"\n  ) %&gt;%\n  filter(!is.na(event_date)) %&gt;%\n  mutate(\n    graft_status = case_when(\n      event_type == \"TDATE\" ~ \"Active\",\n      event_type == \"FAILDATE\" ~ \"Failed\"\n    )\n  ) %&gt;%\n  select(-event_type)%&gt;%\n  arrange(USRDS_ID, cumulative_transplant_total, event_date, graft_status)\n\n\n#Initialize a flowchart cohort\npatients_clean&lt;-patients_raw%&gt;%\n  as_fc(label=\"Patients in USRDS\")%&gt;%\n  \n  \n  fc_filter(TOTTX&gt;0, \n            label=\"Prior transplant\", \n            label_exc = \"Excluded: No prior transplant\", \n            show_exc = TRUE)%&gt;%\n  \n  fc_filter(TX1DATE&lt;as.Date(\"2021-01-01\"), \n            label=\"Transplant prior to 2021\", \n            label_exc = \"Excluded: Transplant 2021 or later\", \n            show_exc = TRUE)\n\n\n\n#Create list of USRDS ids for patients who have undergone transplant\ntransplant_id_list&lt;-patients_clean$data%&gt;%\n  pull(USRDS_ID)\n\n# We now seek to determine comorbidities by using diagnosis codes from the setup.R file\n\ncomorbidity_diagnosis_date&lt;-list()\n\n# Combine all ICD codes from all comorbidities into one list \ncomorbidity_ICD_combined_list&lt;-unlist(comorbidity_ICD_list, use.names=FALSE)\n\n#Scrape files for any comorbidity claim\ncomorbidity_claims_df&lt;-bind_rows(get_IN_ICD(icd_codes = comorbidity_ICD_combined_list, \n                                            years = 2006:2021, \n                                            usrds_ids = transplant_id_list ),\n                                 get_PS_ICD(icd_codes = comorbidity_ICD_combined_list, \n                                            years = 2006:2021, \n                                            usrds_ids = transplant_id_list )%&gt;%rename(CODE=DIAG))%&gt;%\n  arrange(USRDS_ID, CLM_FROM)\n\n#Create comorbidity_diagnosis_date data frame\nfor (comorbidity in names(comorbidity_ICD_list)){\n  \n  comorbidity_diagnosis_date[[comorbidity]]&lt;-comorbidity_claims_df%&gt;%\n    filter(CODE %in% comorbidity_ICD_list[[comorbidity]])%&gt;%\n    establish_dx_date(diagnosis_established = comorbidity)\n}\n\n#Load Medicare coverage history for all patients with transplant\nmedicare_history&lt;-load_usrds_file(\"payhist\",\n                                  usrds_ids = transplant_id_list)%&gt;%\n  arrange(USRDS_ID, BEGDATE)%&gt;%\n  group_by(USRDS_ID)%&gt;%\n  mutate(lag_ENDDATE=lag(ENDDATE))%&gt;%\n  mutate(gap=as.numeric(BEGDATE-lag_ENDDATE))%&gt;%\n  arrange(desc(gap))\n\n#Confirm no gaps (gap should always be 1 or missing)\nif (any(!is.na(medicare_history$gap) & medicare_history$gap != 1)) {\n  stop(\"Gap assumption violated: `gap` contains values other than 1 or NA.\")\n}\n\n#Add cryptococcus diagnosis date to patients_clean$data\n#First, format a df with the cryptococcus dx\ncryptococcus_df&lt;-comorbidity_diagnosis_date$cryptococcus%&gt;%\n  select(-diagnosis)%&gt;%\n  rename(cryptococcus_dx_date=date_established)\n\n\n\n#Join cryptococcus date to fc cohort\npatients_clean$data&lt;-left_join(patients_clean$data, \n                               cryptococcus_df)%&gt;%\n  mutate(cryptococcus_case=ifelse(is.na(cryptococcus_dx_date), \"Potential control\", \"Case\"))\n\n#Continue to create analytic cohort\npatients_merged&lt;-patients_clean%&gt;%\n  \n  #Remove patients with a diagnosis of cryptococcus prior to transplant\n  fc_filter(cryptococcus_dx_date&gt;TX1DATE | is.na(cryptococcus_dx_date), \n            label=\"No cryptococcus dx prior to transplant\", \n            label_exc = \"Excluded: cryptococcus dx prior to transplant\", \n            show_exc = TRUE)%&gt;%\n  \n  fc_filter((time_length(interval(BORN, cryptococcus_dx_date), \"years\") &gt;= 18) | is.na(cryptococcus_dx_date),\n            label=\"Age 18+ at time of cryptococcus if cryptococcus patient\", \n            label_exc = \"Excluded: First cryptococcus prior to age 18\", \n            show_exc = TRUE)%&gt;%\n  \n  fc_filter((year(cryptococcus_dx_date)&gt;=2007 & year(cryptococcus_dx_date)&lt;=2020) | is.na(cryptococcus_dx_date),\n            label=\"Incident cryptococcus between 1/1/2007 and 12/31/2020\", \n            label_exc = \"Incident cryptococcus outside of specified date range\", \n            show_exc = TRUE)%&gt;%\n  \n  #Split cohorts\n  fc_split(cryptococcus_case)\n  \n  #Check Medicare coverage for 365-day lookback period from day of first episode of cryptococcus\npatients_merged$data&lt;-patients_merged$data%&gt;%\n  verify_medicare_primary(index_date = \"cryptococcus_dx_date\",\n                          lookback_days = 365,\n                          coverage_start_variable = \"coverage_start_date\",\n                          coverage_end_variable = \"coverage_end_date\"\n                          )%&gt;%\n  mutate(medicare_primary_TF=ifelse(cryptococcus_case==\"Potential control\", TRUE, medicare_primary_TF))\n  \npatients_merged2&lt;-patients_merged%&gt;%\n  \n  fc_filter(medicare_primary_TF==TRUE, \n            label = \"365+ days of Medicare primary coverage\\nprior to first cryptococcus claim\", \n            label_exc = \"Excluded: Fewer than 365 days of coverage\",\n            show_exc = TRUE)\n\npatients_merged2$data&lt;-patients_merged2$data%&gt;%\n  select(-medicare_primary_TF)%&gt;%\n  \n  #Prepare data for cohort initialization\n  mutate(terminal_date=coalesce(coverage_end_date, censor_date))\n\npatients_merged2&lt;-patients_merged2%&gt;%\n  fc_filter((terminal_date - cryptococcus_dx_date &gt;=minimum_followup) | is.na(cryptococcus_dx_date), \n            label = \"Minimum followup exceeded\", \n            label_exc= \"Excluded: Minimum follow-up threshold not met\",\n            show_exc = TRUE)\n\n  \npatients_merged2%&gt;%\n  fc_draw()\n\n\n#Now we need to construct the time-varying data set\n\n#Ungroup\ninitial_cohort&lt;-patients_merged2$data%&gt;%\n  ungroup()%&gt;%\n\n#Cases join when they experience cryptococcus\n#Controls start on date of first transplant\n  mutate(\n    cohort_join_date = coalesce(\n      as.Date(cryptococcus_dx_date),\n      as.Date(TX1DATE)\n    )\n  )\n\n#Initialize cohort\nprematching_cohort&lt;-create_usrds_cohort(df=initial_cohort,\n                            start_date = \"cohort_join_date\",\n                            end_date = \"terminal_date\")%&gt;%\n  \n  # Add cirrhosis\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"cirrhosis\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"cirrhosis\")%&gt;%\n  \n  # Add CMV\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"CMV\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"CMV\")%&gt;%\n  \n  # Add diabetes\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Diabetes\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"diabetes\")%&gt;%\n  \n  # Add HIV\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"HIV\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"HIV\")%&gt;%\n  \n  # Add liver transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Liver transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"liver_transplant\")%&gt;%\n  \n  # Add lung transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Lung transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"lung_transplant\")%&gt;%\n  \n  # Add heart transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Heart transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"heart_transplant\")%&gt;%\n  \n  # Add pancreas transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Pancreas transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"pancreas_transplant\")%&gt;%\n  \n  # Add heart-lung transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Heart-lung transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"heartlung_transplant\")%&gt;%\n  \n  # Add intestinal transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Intestinal transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"intestinal_transplant\")%&gt;%\n  \n  #Add time-varying information about transplant status\n  add_cohort_covariate(covariate_data_frame=tx_status,\n                       covariate_date=\"event_date\",\n                       covariate_variable_name=\"cumulative_transplant_total\",\n                       covariate_value = \"cumulative_transplant_total\")%&gt;%\n  \n  #Add time-varying information about transplant status (whether current graft is active or failed)\n  add_cohort_covariate(covariate_data_frame=tx_status,\n                       covariate_date=\"event_date\",\n                       covariate_variable_name=\"current_graft_status\",\n                       covariate_value = \"graft_status\")%&gt;%\n  \n  #Add time-varying information about transplant status (date of most recent transplant)\n  add_cohort_covariate(covariate_data_frame=tx_status%&gt;%filter(graft_status==\"Active\"),\n                       covariate_date=\"event_date\",\n                       covariate_variable_name=\"most_recent_transplant_date\",\n                       covariate_value = \"event_date\")%&gt;%\n  \n  #Add time-varying information about transplant status (date of most recent graft failure)\n  add_cohort_covariate(covariate_data_frame=tx_status%&gt;%filter(graft_status==\"Failed\"),\n                       covariate_date=\"event_date\",\n                       covariate_variable_name=\"most_recent_failure_date\",\n                       covariate_value = \"event_date\")%&gt;%\n  \n  # Add Medicare current coverage\n  add_cohort_covariate(covariate_data_frame=medicare_history,\n                       covariate_date=\"BEGDATE\",\n                       covariate_variable_name=\"current_medicare_coverage\",\n                       covariate_value = \"PAYER\"\n                       )%&gt;%\n  \n  finalize_usrds_cohort(baseline_date_variable = \"most_recent_transplant_date\")"
  },
  {
    "objectID": "quarto/execute_matching.html#other-portions-of-the-analysis",
    "href": "quarto/execute_matching.html#other-portions-of-the-analysis",
    "title": "Execute matching",
    "section": "",
    "text": "Setup\nAbout: methods, assumptions, and disclosures"
  },
  {
    "objectID": "quarto/modeling.html",
    "href": "quarto/modeling.html",
    "title": "Modeling",
    "section": "",
    "text": "The code in this script runs the statistical models used in the R.figures.R and R.tables.R scripts to generate tables and figures for the manuscript."
  },
  {
    "objectID": "quarto/modeling.html#create-cohort",
    "href": "quarto/modeling.html#create-cohort",
    "title": "Create cohort",
    "section": "",
    "text": "The code in this script creates the cohort of kidney transplant patients eligible for the study\n\n\n\n\n\n\nSource code\n\n\n\nThe full R script is available at:\n\nR/create_cohort.R\n\nThis R script file is itself reliant on the following helper files:\n\nR/setup.R\nR/functions.R"
  },
  {
    "objectID": "quarto/modeling.html#section",
    "href": "quarto/modeling.html#section",
    "title": "Create cohort",
    "section": "",
    "text": "Code\n#Create a cohort of kidney transplant patients with cryptococcus matched to controls without cryptococcus\n\nsource(\"R/setup.R\")\n\n#Import core demographics from \"patients\" file\npatients_raw&lt;-usRds::load_usrds_file(\"patients\")%&gt;%\n  select(-ZIPCODE) #This is ZIP code at time of USRDS initiation, but we want at time of crypto dx\n\n#Import key information about the transplants from the TX and UNOS databases\ntx_raw&lt;-usRds::load_usrds_file(\"tx\")%&gt;%\n  select(USRDS_ID, TDATE, FAILDATE, TRR_ID_CODE)\n\nki_raw&lt;-usRds::load_usrds_file(\"txunos_trr_ki\")%&gt;%\n  select(USRDS_ID, ORGTYP, HRTX, LUTX, INTX, LITX,PITX,BMTX, TRR_ID_CODE)\n\nkp_raw&lt;-usRds::load_usrds_file(\"txunos_trr_kp\")%&gt;%\n  select(USRDS_ID, ORGTYP, HRTX, LUTX, INTX, LITX,PITX,BMTX, TRR_ID_CODE)\n\n#This combines the three datasets\ntx_clean&lt;-tx_raw%&gt;%\n  left_join(bind_rows(ki_raw,\n                      kp_raw))%&gt;%\n  arrange(USRDS_ID, TDATE)%&gt;%\n  \n  group_by(USRDS_ID)%&gt;%\n  mutate(cumulative_transplant_total=row_number())%&gt;%\n  ungroup\n\n#Create a time-varying dataset that can be used to track whether a pt has an active or inactive graft and the cumulative number of txs\ntx_status&lt;-tx_clean%&gt;%\n  select(USRDS_ID, TDATE, FAILDATE, cumulative_transplant_total)%&gt;%\n  pivot_longer(\n    cols = c(TDATE, FAILDATE),\n    names_to = \"event_type\",\n    values_to = \"event_date\"\n  ) %&gt;%\n  filter(!is.na(event_date)) %&gt;%\n  mutate(\n    graft_status = case_when(\n      event_type == \"TDATE\" ~ \"Active\",\n      event_type == \"FAILDATE\" ~ \"Failed\"\n    )\n  ) %&gt;%\n  select(-event_type)%&gt;%\n  arrange(USRDS_ID, cumulative_transplant_total, event_date, graft_status)\n\n\n#Initialize a flowchart cohort\npatients_clean&lt;-patients_raw%&gt;%\n  as_fc(label=\"Patients in USRDS\")%&gt;%\n  \n  \n  fc_filter(TOTTX&gt;0, \n            label=\"Prior transplant\", \n            label_exc = \"Excluded: No prior transplant\", \n            show_exc = TRUE)%&gt;%\n  \n  fc_filter(TX1DATE&lt;as.Date(\"2021-01-01\"), \n            label=\"Transplant prior to 2021\", \n            label_exc = \"Excluded: Transplant 2021 or later\", \n            show_exc = TRUE)\n\n\n\n#Create list of USRDS ids for patients who have undergone transplant\ntransplant_id_list&lt;-patients_clean$data%&gt;%\n  pull(USRDS_ID)\n\n# We now seek to determine comorbidities by using diagnosis codes from the setup.R file\n\ncomorbidity_diagnosis_date&lt;-list()\n\n# Combine all ICD codes from all comorbidities into one list \ncomorbidity_ICD_combined_list&lt;-unlist(comorbidity_ICD_list, use.names=FALSE)\n\n#Scrape files for any comorbidity claim\ncomorbidity_claims_df&lt;-bind_rows(get_IN_ICD(icd_codes = comorbidity_ICD_combined_list, \n                                            years = 2006:2021, \n                                            usrds_ids = transplant_id_list ),\n                                 get_PS_ICD(icd_codes = comorbidity_ICD_combined_list, \n                                            years = 2006:2021, \n                                            usrds_ids = transplant_id_list )%&gt;%rename(CODE=DIAG))%&gt;%\n  arrange(USRDS_ID, CLM_FROM)\n\n#Create comorbidity_diagnosis_date data frame\nfor (comorbidity in names(comorbidity_ICD_list)){\n  \n  comorbidity_diagnosis_date[[comorbidity]]&lt;-comorbidity_claims_df%&gt;%\n    filter(CODE %in% comorbidity_ICD_list[[comorbidity]])%&gt;%\n    establish_dx_date(diagnosis_established = comorbidity)\n}\n\n#Load Medicare coverage history for all patients with transplant\nmedicare_history&lt;-load_usrds_file(\"payhist\",\n                                  usrds_ids = transplant_id_list)%&gt;%\n  arrange(USRDS_ID, BEGDATE)%&gt;%\n  group_by(USRDS_ID)%&gt;%\n  mutate(lag_ENDDATE=lag(ENDDATE))%&gt;%\n  mutate(gap=as.numeric(BEGDATE-lag_ENDDATE))%&gt;%\n  arrange(desc(gap))\n\n#Confirm no gaps (gap should always be 1 or missing)\nif (any(!is.na(medicare_history$gap) & medicare_history$gap != 1)) {\n  stop(\"Gap assumption violated: `gap` contains values other than 1 or NA.\")\n}\n\n#Add cryptococcus diagnosis date to patients_clean$data\n#First, format a df with the cryptococcus dx\ncryptococcus_df&lt;-comorbidity_diagnosis_date$cryptococcus%&gt;%\n  select(-diagnosis)%&gt;%\n  rename(cryptococcus_dx_date=date_established)\n\n\n\n#Join cryptococcus date to fc cohort\npatients_clean$data&lt;-left_join(patients_clean$data, \n                               cryptococcus_df)%&gt;%\n  mutate(cryptococcus_case=ifelse(is.na(cryptococcus_dx_date), \"Potential control\", \"Case\"))\n\n#Continue to create analytic cohort\npatients_merged&lt;-patients_clean%&gt;%\n  \n  #Remove patients with a diagnosis of cryptococcus prior to transplant\n  fc_filter(cryptococcus_dx_date&gt;TX1DATE | is.na(cryptococcus_dx_date), \n            label=\"No cryptococcus dx prior to transplant\", \n            label_exc = \"Excluded: cryptococcus dx prior to transplant\", \n            show_exc = TRUE)%&gt;%\n  \n  fc_filter((time_length(interval(BORN, cryptococcus_dx_date), \"years\") &gt;= 18) | is.na(cryptococcus_dx_date),\n            label=\"Age 18+ at time of cryptococcus if cryptococcus patient\", \n            label_exc = \"Excluded: First cryptococcus prior to age 18\", \n            show_exc = TRUE)%&gt;%\n  \n  fc_filter((year(cryptococcus_dx_date)&gt;=2007 & year(cryptococcus_dx_date)&lt;=2020) | is.na(cryptococcus_dx_date),\n            label=\"Incident cryptococcus between 1/1/2007 and 12/31/2020\", \n            label_exc = \"Incident cryptococcus outside of specified date range\", \n            show_exc = TRUE)%&gt;%\n  \n  #Split cohorts\n  fc_split(cryptococcus_case)\n  \n  #Check Medicare coverage for 365-day lookback period from day of first episode of cryptococcus\npatients_merged$data&lt;-patients_merged$data%&gt;%\n  verify_medicare_primary(index_date = \"cryptococcus_dx_date\",\n                          lookback_days = 365,\n                          coverage_start_variable = \"coverage_start_date\",\n                          coverage_end_variable = \"coverage_end_date\"\n                          )%&gt;%\n  mutate(medicare_primary_TF=ifelse(cryptococcus_case==\"Potential control\", TRUE, medicare_primary_TF))\n  \npatients_merged2&lt;-patients_merged%&gt;%\n  \n  fc_filter(medicare_primary_TF==TRUE, \n            label = \"365+ days of Medicare primary coverage\\nprior to first cryptococcus claim\", \n            label_exc = \"Excluded: Fewer than 365 days of coverage\",\n            show_exc = TRUE)\n\npatients_merged2$data&lt;-patients_merged2$data%&gt;%\n  select(-medicare_primary_TF)%&gt;%\n  \n  #Prepare data for cohort initialization\n  mutate(terminal_date=coalesce(coverage_end_date, censor_date))\n\npatients_merged2&lt;-patients_merged2%&gt;%\n  fc_filter((terminal_date - cryptococcus_dx_date &gt;=minimum_followup) | is.na(cryptococcus_dx_date), \n            label = \"Minimum followup exceeded\", \n            label_exc= \"Excluded: Minimum follow-up threshold not met\",\n            show_exc = TRUE)\n\n  \npatients_merged2%&gt;%\n  fc_draw()\n\n\n#Now we need to construct the time-varying data set\n\n#Ungroup\ninitial_cohort&lt;-patients_merged2$data%&gt;%\n  ungroup()%&gt;%\n\n#Cases join when they experience cryptococcus\n#Controls start on date of first transplant\n  mutate(\n    cohort_join_date = coalesce(\n      as.Date(cryptococcus_dx_date),\n      as.Date(TX1DATE)\n    )\n  )\n\n#Initialize cohort\nprematching_cohort&lt;-create_usrds_cohort(df=initial_cohort,\n                            start_date = \"cohort_join_date\",\n                            end_date = \"terminal_date\")%&gt;%\n  \n  # Add cirrhosis\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"cirrhosis\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"cirrhosis\")%&gt;%\n  \n  # Add CMV\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"CMV\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"CMV\")%&gt;%\n  \n  # Add diabetes\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Diabetes\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"diabetes\")%&gt;%\n  \n  # Add HIV\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"HIV\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"HIV\")%&gt;%\n  \n  # Add liver transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Liver transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"liver_transplant\")%&gt;%\n  \n  # Add lung transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Lung transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"lung_transplant\")%&gt;%\n  \n  # Add heart transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Heart transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"heart_transplant\")%&gt;%\n  \n  # Add pancreas transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Pancreas transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"pancreas_transplant\")%&gt;%\n  \n  # Add heart-lung transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Heart-lung transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"heartlung_transplant\")%&gt;%\n  \n  # Add intestinal transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Intestinal transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"intestinal_transplant\")%&gt;%\n  \n  #Add time-varying information about transplant status\n  add_cohort_covariate(covariate_data_frame=tx_status,\n                       covariate_date=\"event_date\",\n                       covariate_variable_name=\"cumulative_transplant_total\",\n                       covariate_value = \"cumulative_transplant_total\")%&gt;%\n  \n  #Add time-varying information about transplant status (whether current graft is active or failed)\n  add_cohort_covariate(covariate_data_frame=tx_status,\n                       covariate_date=\"event_date\",\n                       covariate_variable_name=\"current_graft_status\",\n                       covariate_value = \"graft_status\")%&gt;%\n  \n  #Add time-varying information about transplant status (date of most recent transplant)\n  add_cohort_covariate(covariate_data_frame=tx_status%&gt;%filter(graft_status==\"Active\"),\n                       covariate_date=\"event_date\",\n                       covariate_variable_name=\"most_recent_transplant_date\",\n                       covariate_value = \"event_date\")%&gt;%\n  \n  #Add time-varying information about transplant status (date of most recent graft failure)\n  add_cohort_covariate(covariate_data_frame=tx_status%&gt;%filter(graft_status==\"Failed\"),\n                       covariate_date=\"event_date\",\n                       covariate_variable_name=\"most_recent_failure_date\",\n                       covariate_value = \"event_date\")%&gt;%\n  \n  # Add Medicare current coverage\n  add_cohort_covariate(covariate_data_frame=medicare_history,\n                       covariate_date=\"BEGDATE\",\n                       covariate_variable_name=\"current_medicare_coverage\",\n                       covariate_value = \"PAYER\"\n                       )%&gt;%\n  \n  finalize_usrds_cohort(baseline_date_variable = \"most_recent_transplant_date\")"
  },
  {
    "objectID": "quarto/modeling.html#other-portions-of-the-analysis",
    "href": "quarto/modeling.html#other-portions-of-the-analysis",
    "title": "Modeling",
    "section": "Other portions of the analysis",
    "text": "Other portions of the analysis\n\nAbout: methods, assumptions, and disclosures"
  },
  {
    "objectID": "quarto/create_cohort.html#initial-data-load-and-clean",
    "href": "quarto/create_cohort.html#initial-data-load-and-clean",
    "title": "Create cohort",
    "section": "Initial data load and clean",
    "text": "Initial data load and clean\nThis portion of the code imports the USRDS data and makes extensive use of the usRds package developed by the authors and tidyverse cleaning functions.\nKey files used:\n\npatients: This is a part of the Core data set of the USRDS and contains key patient demographics.\ntx: Also a part of the Core data set of the USRDS and contains summary information about kidney transplants from UNOS.\ntxunos_trr_ki and txunos_trr_kp: Part of the transplant data set of the USRDS, these files contain more detailed information derived from UNOS that is part of the Scientific Registry of Transplant Recipients.\n\n\n\nCode\n#Import core demographics from \"patients\" file\npatients_raw&lt;-usRds::load_usrds_file(\"patients\")%&gt;%\n  select(-ZIPCODE) #This is ZIP code at time of USRDS initiation, but we want at time of crypto dx\n\n#Import key information about the transplants from the TX and UNOS databases\ntx_raw&lt;-usRds::load_usrds_file(\"tx\")%&gt;%\n  select(USRDS_ID, TDATE, FAILDATE, TRR_ID_CODE)\n\nki_raw&lt;-usRds::load_usrds_file(\"txunos_trr_ki\")%&gt;%\n  select(USRDS_ID, ORGTYP, HRTX, LUTX, INTX, LITX,PITX,BMTX, TRR_ID_CODE)\n\nkp_raw&lt;-usRds::load_usrds_file(\"txunos_trr_kp\")%&gt;%\n  select(USRDS_ID, ORGTYP, HRTX, LUTX, INTX, LITX,PITX,BMTX, TRR_ID_CODE)\n\n#This combines the three datasets\ntx_clean&lt;-tx_raw%&gt;%\n  left_join(bind_rows(ki_raw,\n                      kp_raw))%&gt;%\n  arrange(USRDS_ID, TDATE)%&gt;%\n  \n  group_by(USRDS_ID)%&gt;%\n  mutate(cumulative_transplant_total=row_number())%&gt;%\n  ungroup\n\n#Create a time-varying dataset that can be used to track whether a pt has an active or inactive graft and the cumulative number of txs\ntx_status&lt;-tx_clean%&gt;%\n  select(USRDS_ID, TDATE, FAILDATE, cumulative_transplant_total)%&gt;%\n  pivot_longer(\n    cols = c(TDATE, FAILDATE),\n    names_to = \"event_type\",\n    values_to = \"event_date\"\n  ) %&gt;%\n  filter(!is.na(event_date)) %&gt;%\n  mutate(\n    graft_status = case_when(\n      event_type == \"TDATE\" ~ \"Active\",\n      event_type == \"FAILDATE\" ~ \"Failed\"\n    )\n  ) %&gt;%\n  select(-event_type)%&gt;%\n  arrange(USRDS_ID, cumulative_transplant_total, event_date, graft_status)\n\n\n\n\nCode\n#Create a cohort of kidney transplant patients with cryptococcus matched to controls without cryptococcus\n\n\n\n\n#Initialize a flowchart cohort\npatients_clean&lt;-patients_raw%&gt;%\n  as_fc(label=\"Patients in USRDS\")%&gt;%\n  \n  \n  fc_filter(TOTTX&gt;0, \n            label=\"Prior transplant\", \n            label_exc = \"Excluded: No prior transplant\", \n            show_exc = TRUE)%&gt;%\n  \n  fc_filter(TX1DATE&lt;as.Date(\"2021-01-01\"), \n            label=\"Transplant prior to 2021\", \n            label_exc = \"Excluded: Transplant 2021 or later\", \n            show_exc = TRUE)\n\n\n\n#Create list of USRDS ids for patients who have undergone transplant\ntransplant_id_list&lt;-patients_clean$data%&gt;%\n  pull(USRDS_ID)\n\n# We now seek to determine comorbidities by using diagnosis codes from the setup.R file\n\ncomorbidity_diagnosis_date&lt;-list()\n\n# Combine all ICD codes from all comorbidities into one list \ncomorbidity_ICD_combined_list&lt;-unlist(comorbidity_ICD_list, use.names=FALSE)\n\n#Scrape files for any comorbidity claim\ncomorbidity_claims_df&lt;-bind_rows(get_IN_ICD(icd_codes = comorbidity_ICD_combined_list, \n                                            years = 2006:2021, \n                                            usrds_ids = transplant_id_list ),\n                                 get_PS_ICD(icd_codes = comorbidity_ICD_combined_list, \n                                            years = 2006:2021, \n                                            usrds_ids = transplant_id_list )%&gt;%rename(CODE=DIAG))%&gt;%\n  arrange(USRDS_ID, CLM_FROM)\n\n#Create comorbidity_diagnosis_date data frame\nfor (comorbidity in names(comorbidity_ICD_list)){\n  \n  comorbidity_diagnosis_date[[comorbidity]]&lt;-comorbidity_claims_df%&gt;%\n    filter(CODE %in% comorbidity_ICD_list[[comorbidity]])%&gt;%\n    establish_dx_date(diagnosis_established = comorbidity)\n}\n\n#Load Medicare coverage history for all patients with transplant\nmedicare_history&lt;-load_usrds_file(\"payhist\",\n                                  usrds_ids = transplant_id_list)%&gt;%\n  arrange(USRDS_ID, BEGDATE)%&gt;%\n  group_by(USRDS_ID)%&gt;%\n  mutate(lag_ENDDATE=lag(ENDDATE))%&gt;%\n  mutate(gap=as.numeric(BEGDATE-lag_ENDDATE))%&gt;%\n  arrange(desc(gap))\n\n#Confirm no gaps (gap should always be 1 or missing)\nif (any(!is.na(medicare_history$gap) & medicare_history$gap != 1)) {\n  stop(\"Gap assumption violated: `gap` contains values other than 1 or NA.\")\n}\n\n#Add cryptococcus diagnosis date to patients_clean$data\n#First, format a df with the cryptococcus dx\ncryptococcus_df&lt;-comorbidity_diagnosis_date$cryptococcus%&gt;%\n  select(-diagnosis)%&gt;%\n  rename(cryptococcus_dx_date=date_established)\n\n\n\n#Join cryptococcus date to fc cohort\npatients_clean$data&lt;-left_join(patients_clean$data, \n                               cryptococcus_df)%&gt;%\n  mutate(cryptococcus_case=ifelse(is.na(cryptococcus_dx_date), \"Potential control\", \"Case\"))\n\n#Continue to create analytic cohort\npatients_merged&lt;-patients_clean%&gt;%\n  \n  #Remove patients with a diagnosis of cryptococcus prior to transplant\n  fc_filter(cryptococcus_dx_date&gt;TX1DATE | is.na(cryptococcus_dx_date), \n            label=\"No cryptococcus dx prior to transplant\", \n            label_exc = \"Excluded: cryptococcus dx prior to transplant\", \n            show_exc = TRUE)%&gt;%\n  \n  fc_filter((time_length(interval(BORN, cryptococcus_dx_date), \"years\") &gt;= 18) | is.na(cryptococcus_dx_date),\n            label=\"Age 18+ at time of cryptococcus if cryptococcus patient\", \n            label_exc = \"Excluded: First cryptococcus prior to age 18\", \n            show_exc = TRUE)%&gt;%\n  \n  fc_filter((year(cryptococcus_dx_date)&gt;=2007 & year(cryptococcus_dx_date)&lt;=2020) | is.na(cryptococcus_dx_date),\n            label=\"Incident cryptococcus between 1/1/2007 and 12/31/2020\", \n            label_exc = \"Incident cryptococcus outside of specified date range\", \n            show_exc = TRUE)%&gt;%\n  \n  #Split cohorts\n  fc_split(cryptococcus_case)\n  \n  #Check Medicare coverage for 365-day lookback period from day of first episode of cryptococcus\npatients_merged$data&lt;-patients_merged$data%&gt;%\n  verify_medicare_primary(index_date = \"cryptococcus_dx_date\",\n                          lookback_days = 365,\n                          coverage_start_variable = \"coverage_start_date\",\n                          coverage_end_variable = \"coverage_end_date\"\n                          )%&gt;%\n  mutate(medicare_primary_TF=ifelse(cryptococcus_case==\"Potential control\", TRUE, medicare_primary_TF))\n  \npatients_merged2&lt;-patients_merged%&gt;%\n  \n  fc_filter(medicare_primary_TF==TRUE, \n            label = \"365+ days of Medicare primary coverage\\nprior to first cryptococcus claim\", \n            label_exc = \"Excluded: Fewer than 365 days of coverage\",\n            show_exc = TRUE)\n\npatients_merged2$data&lt;-patients_merged2$data%&gt;%\n  select(-medicare_primary_TF)%&gt;%\n  \n  #Prepare data for cohort initialization\n  mutate(terminal_date=coalesce(coverage_end_date, censor_date))\n\npatients_merged2&lt;-patients_merged2%&gt;%\n  fc_filter((terminal_date - cryptococcus_dx_date &gt;=minimum_followup) | is.na(cryptococcus_dx_date), \n            label = \"Minimum followup exceeded\", \n            label_exc= \"Excluded: Minimum follow-up threshold not met\",\n            show_exc = TRUE)\n\n  \npatients_merged2%&gt;%\n  fc_draw()\n\n\n#Now we need to construct the time-varying data set\n\n#Ungroup\ninitial_cohort&lt;-patients_merged2$data%&gt;%\n  ungroup()%&gt;%\n\n#Cases join when they experience cryptococcus\n#Controls start on date of first transplant\n  mutate(\n    cohort_join_date = coalesce(\n      as.Date(cryptococcus_dx_date),\n      as.Date(TX1DATE)\n    )\n  )\n\n#Initialize cohort\nprematching_cohort&lt;-create_usrds_cohort(df=initial_cohort,\n                            start_date = \"cohort_join_date\",\n                            end_date = \"terminal_date\")%&gt;%\n  \n  # Add cirrhosis\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"cirrhosis\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"cirrhosis\")%&gt;%\n  \n  # Add CMV\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"CMV\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"CMV\")%&gt;%\n  \n  # Add diabetes\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Diabetes\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"diabetes\")%&gt;%\n  \n  # Add HIV\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"HIV\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"HIV\")%&gt;%\n  \n  # Add liver transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Liver transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"liver_transplant\")%&gt;%\n  \n  # Add lung transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Lung transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"lung_transplant\")%&gt;%\n  \n  # Add heart transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Heart transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"heart_transplant\")%&gt;%\n  \n  # Add pancreas transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Pancreas transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"pancreas_transplant\")%&gt;%\n  \n  # Add heart-lung transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Heart-lung transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"heartlung_transplant\")%&gt;%\n  \n  # Add intestinal transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Intestinal transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"intestinal_transplant\")%&gt;%\n  \n  #Add time-varying information about transplant status\n  add_cohort_covariate(covariate_data_frame=tx_status,\n                       covariate_date=\"event_date\",\n                       covariate_variable_name=\"cumulative_transplant_total\",\n                       covariate_value = \"cumulative_transplant_total\")%&gt;%\n  \n  #Add time-varying information about transplant status (whether current graft is active or failed)\n  add_cohort_covariate(covariate_data_frame=tx_status,\n                       covariate_date=\"event_date\",\n                       covariate_variable_name=\"current_graft_status\",\n                       covariate_value = \"graft_status\")%&gt;%\n  \n  #Add time-varying information about transplant status (date of most recent transplant)\n  add_cohort_covariate(covariate_data_frame=tx_status%&gt;%filter(graft_status==\"Active\"),\n                       covariate_date=\"event_date\",\n                       covariate_variable_name=\"most_recent_transplant_date\",\n                       covariate_value = \"event_date\")%&gt;%\n  \n  #Add time-varying information about transplant status (date of most recent graft failure)\n  add_cohort_covariate(covariate_data_frame=tx_status%&gt;%filter(graft_status==\"Failed\"),\n                       covariate_date=\"event_date\",\n                       covariate_variable_name=\"most_recent_failure_date\",\n                       covariate_value = \"event_date\")%&gt;%\n  \n  # Add Medicare current coverage\n  add_cohort_covariate(covariate_data_frame=medicare_history,\n                       covariate_date=\"BEGDATE\",\n                       covariate_variable_name=\"current_medicare_coverage\",\n                       covariate_value = \"PAYER\"\n                       )%&gt;%\n  \n  finalize_usrds_cohort(baseline_date_variable = \"most_recent_transplant_date\")"
  },
  {
    "objectID": "quarto/create_cohort.html#initial-data-loading-and-preprocessing-of-usrds-core-and-transplant-files",
    "href": "quarto/create_cohort.html#initial-data-loading-and-preprocessing-of-usrds-core-and-transplant-files",
    "title": "Create cohort",
    "section": "",
    "text": "This portion of the code imports files from the USRDS data set necessary for the cryptococcus analysis. This portion makes use of the load_usrds_data() function from the usRds package as well as several tidyverse cleaning functions.\nKey files used:\n\npatients: This is a part of the Core data set of the USRDS and contains key patient demographics.\ntx: Also a part of the Core data set of the USRDS and contains summary information about kidney transplants from UNOS.\ntxunos_trr_ki and txunos_trr_kp: Part of the transplant data set of the USRDS, these files contain more detailed information derived from UNOS that is part of the Scientific Registry of Transplant Recipients.\n\nThe code below loads and merges transplant records across multiple UNOS-derived files, constructs a cumulative transplant count per patient, and reshapes the data into a time-varying format that tracks graft status over time.\n\n\nCode\n#Import core demographics from \"patients\" file\npatients_raw&lt;-usRds::load_usrds_file(\"patients\")%&gt;%\n  select(-ZIPCODE) #This is ZIP code at time of USRDS initiation, but we want at time of crypto dx\n\n#Import key information about the transplants from the TX and UNOS databases\ntx_raw&lt;-usRds::load_usrds_file(\"tx\")%&gt;%\n  select(USRDS_ID, TDATE, FAILDATE, TRR_ID_CODE)\n\nki_raw&lt;-usRds::load_usrds_file(\"txunos_trr_ki\")%&gt;%\n  select(USRDS_ID, ORGTYP, HRTX, LUTX, INTX, LITX,PITX,BMTX, TRR_ID_CODE)\n\nkp_raw&lt;-usRds::load_usrds_file(\"txunos_trr_kp\")%&gt;%\n  select(USRDS_ID, ORGTYP, HRTX, LUTX, INTX, LITX,PITX,BMTX, TRR_ID_CODE)\n\n#This combines the three datasets\ntx_clean&lt;-tx_raw%&gt;%\n  left_join(bind_rows(ki_raw,\n                      kp_raw))%&gt;%\n  arrange(USRDS_ID, TDATE)%&gt;%\n  \n  group_by(USRDS_ID)%&gt;%\n  mutate(cumulative_transplant_total=row_number())%&gt;%\n  ungroup\n\n#Create a time-varying dataset that can be used to track whether a pt has an active or inactive graft and the cumulative number of txs\ntx_status&lt;-tx_clean%&gt;%\n  select(USRDS_ID, TDATE, FAILDATE, cumulative_transplant_total)%&gt;%\n  pivot_longer(\n    cols = c(TDATE, FAILDATE),\n    names_to = \"event_type\",\n    values_to = \"event_date\"\n  ) %&gt;%\n  filter(!is.na(event_date)) %&gt;%\n  mutate(\n    graft_status = case_when(\n      event_type == \"TDATE\" ~ \"Active\",\n      event_type == \"FAILDATE\" ~ \"Failed\"\n    )\n  ) %&gt;%\n  select(-event_type)%&gt;%\n  arrange(USRDS_ID, cumulative_transplant_total, event_date, graft_status)"
  },
  {
    "objectID": "quarto/create_cohort.html#initialize-flowchart",
    "href": "quarto/create_cohort.html#initialize-flowchart",
    "title": "Create cohort",
    "section": "",
    "text": "The next component makes use of the flowchart package. This package combines two key processes in an epidemiologic analysis:\n\nDataset preparation: Sequential application of eligibility criteria to define the analytic cohort, with explicit tracking of excluded records at each step.\nSTROBE diagram preparation: STrengthening the Reporting of OBservational studies in Epidemiology diagrams visually depict the process of including/excluding patients in an observational study and grouping them into cohorts. Many journals require these as a standard Figure 1.\n\nThe code below initializes a flowchart-aware cohort object and applies sequential eligibility filters, retaining both inclusion counts and labeled exclusion steps for downstream reporting.\n\n\nCode\n#Initialize a flowchart cohort\npatients_clean&lt;-patients_raw%&gt;%\n  as_fc(label=\"Patients in USRDS\")%&gt;%\n  \n  \n  fc_filter(TOTTX&gt;0, \n            label=\"Prior transplant\", \n            label_exc = \"Excluded: No prior transplant\", \n            show_exc = TRUE)%&gt;%\n  \n  fc_filter(TX1DATE&lt;as.Date(\"2021-01-01\"), \n            label=\"Transplant prior to 2021\", \n            label_exc = \"Excluded: Transplant 2021 or later\", \n            show_exc = TRUE)"
  },
  {
    "objectID": "quarto/create_cohort.html#identification-of-comorbidities-and-confirmation-of-medicare-coverage-continuity",
    "href": "quarto/create_cohort.html#identification-of-comorbidities-and-confirmation-of-medicare-coverage-continuity",
    "title": "Create cohort",
    "section": "",
    "text": "This component identifies baseline comorbidities among transplant recipients using diagnosis codes derived from Medicare Institutional (Part A) and physician/supplier (Part B) claims. Diagnosis code lists defined in R/setup.R are applied uniformly across claims files to establish the presence and timing of comorbid conditions.\nThis portion makes use of the get_IN_ICD() and get_PS_ICD() functions from the usRds package to obtain dates that specific ICD codes are used for patients with a history of at least one kidney transplant in the study period.\nThe establish_dx_date() function from the usRds package uses the results of this analysis to ascertain the date when comorbidities meet the criteria for a formal diagnosis:\n\nTwo outpatient encounters or\nOne inpatient encounter\n\nIn parallel, Medicare coverage history is retrieved for all transplant recipients from the payhist file, which is part of the Core dataest. These data will be used to confirm continuous enrollment during the analytic period. We verify the absence of gaps indicating missing data, noting that every subsequent period in the dataset for a patient starts the day after the previous period ends and thereby supporting valid longitudinal assessment of diagnoses and downstream cost analyses.\nFinally, we separate cryptococcus diagnosis dates from other comorbidities for a separate list, given the key nature of the date of cryptococcus diagnosis for subsequent analyses.\n\n\nCode\n#Create list of USRDS ids for patients who have undergone transplant\ntransplant_id_list&lt;-patients_clean$data%&gt;%\n  pull(USRDS_ID)\n\n# We now seek to determine comorbidities by using diagnosis codes from the setup.R file\n\ncomorbidity_diagnosis_date&lt;-list()\n\n# Combine all ICD codes from all comorbidities into one list \ncomorbidity_ICD_combined_list&lt;-unlist(comorbidity_ICD_list, use.names=FALSE)\n\n#Scrape files for any comorbidity claim\ncomorbidity_claims_df&lt;-bind_rows(get_IN_ICD(icd_codes = comorbidity_ICD_combined_list, \n                                            years = 2006:2021, \n                                            usrds_ids = transplant_id_list ),\n                                 get_PS_ICD(icd_codes = comorbidity_ICD_combined_list, \n                                            years = 2006:2021, \n                                            usrds_ids = transplant_id_list )%&gt;%rename(CODE=DIAG))%&gt;%\n  arrange(USRDS_ID, CLM_FROM)\n\n#Create comorbidity_diagnosis_date data frame\nfor (comorbidity in names(comorbidity_ICD_list)){\n  \n  comorbidity_diagnosis_date[[comorbidity]]&lt;-comorbidity_claims_df%&gt;%\n    filter(CODE %in% comorbidity_ICD_list[[comorbidity]])%&gt;%\n    establish_dx_date(diagnosis_established = comorbidity)\n}\n\n#Load Medicare coverage history for all patients with transplant\nmedicare_history&lt;-load_usrds_file(\"payhist\",\n                                  usrds_ids = transplant_id_list)%&gt;%\n  arrange(USRDS_ID, BEGDATE)%&gt;%\n  group_by(USRDS_ID)%&gt;%\n  mutate(lag_ENDDATE=lag(ENDDATE))%&gt;%\n  mutate(gap=as.numeric(BEGDATE-lag_ENDDATE))%&gt;%\n  arrange(desc(gap))\n\n#Confirm no gaps (gap should always be 1 or missing)\nif (any(!is.na(medicare_history$gap) & medicare_history$gap != 1)) {\n  stop(\"Gap assumption violated: `gap` contains values other than 1 or NA.\")\n}\n\n\n#Format a df with the cryptococcus dx\ncryptococcus_df&lt;-comorbidity_diagnosis_date$cryptococcus%&gt;%\n  select(-diagnosis)%&gt;%\n  rename(cryptococcus_dx_date=date_established)"
  },
  {
    "objectID": "quarto/create_cohort.html#further-development-of-the-strobe-flowchart",
    "href": "quarto/create_cohort.html#further-development-of-the-strobe-flowchart",
    "title": "Create cohort",
    "section": "",
    "text": "Subsequently, key diagnosis dates, including the date of cryptococcosis diagnosis, are merged into the analytic patient dataset.\nThis code block then extends the STROBE flowchart by integrating diagnosis timing, eligibility criteria, and coverage requirements to finalize the analytic cohorts. Patients are classified as cryptococcosis cases or potential controls based on the presence and timing of diagnosis, and sequential exclusion criteria are applied to ensure incident disease, adult status at diagnosis, and appropriate calendar-time eligibility.\nThe verify_medicare_primary() function from the usrds package is used to confirm that patients with a cryptococcus diagnosis have Medicare primary coverage for at least 365 days prior to the cryptococcus diagnosis date to ensure that the diagnosis is new and not a carryover from an unobserved period.\nThese steps culminate in the final case and control cohorts, with all inclusion and exclusion decisions explicitly tracked and visualized in the updated STROBE flow diagram.\n\n\nCode\n#Join cryptococcus date to fc cohort\npatients_clean$data&lt;-left_join(patients_clean$data, \n                               cryptococcus_df)%&gt;%\n  mutate(cryptococcus_case=ifelse(is.na(cryptococcus_dx_date), \"Potential control\", \"Case\"))\n\n#Continue to create analytic cohort\npatients_merged&lt;-patients_clean%&gt;%\n  \n  #Remove patients with a diagnosis of cryptococcus prior to transplant\n  fc_filter(cryptococcus_dx_date&gt;TX1DATE | is.na(cryptococcus_dx_date), \n            label=\"No cryptococcus dx prior to transplant\", \n            label_exc = \"Excluded: cryptococcus dx prior to transplant\", \n            show_exc = TRUE)%&gt;%\n  \n  fc_filter((time_length(interval(BORN, cryptococcus_dx_date), \"years\") &gt;= 18) | is.na(cryptococcus_dx_date),\n            label=\"Age 18+ at time of cryptococcus if cryptococcus patient\", \n            label_exc = \"Excluded: First cryptococcus prior to age 18\", \n            show_exc = TRUE)%&gt;%\n  \n  fc_filter((year(cryptococcus_dx_date)&gt;=2007 & year(cryptococcus_dx_date)&lt;=2020) | is.na(cryptococcus_dx_date),\n            label=\"Incident cryptococcus between 1/1/2007 and 12/31/2020\", \n            label_exc = \"Incident cryptococcus outside of specified date range\", \n            show_exc = TRUE)%&gt;%\n  \n  #Split cohorts\n  fc_split(cryptococcus_case)\n  \n  #Check Medicare coverage for 365-day lookback period from day of first episode of cryptococcus\npatients_merged$data&lt;-patients_merged$data%&gt;%\n  verify_medicare_primary(index_date = \"cryptococcus_dx_date\",\n                          lookback_days = 365,\n                          coverage_start_variable = \"coverage_start_date\",\n                          coverage_end_variable = \"coverage_end_date\"\n                          )%&gt;%\n  mutate(medicare_primary_TF=ifelse(cryptococcus_case==\"Potential control\", TRUE, medicare_primary_TF))\n  \npatients_merged2&lt;-patients_merged%&gt;%\n  \n  fc_filter(medicare_primary_TF==TRUE, \n            label = \"365+ days of Medicare primary coverage\\nprior to first cryptococcus claim\", \n            label_exc = \"Excluded: Fewer than 365 days of coverage\",\n            show_exc = TRUE)\n\npatients_merged2$data&lt;-patients_merged2$data%&gt;%\n  select(-medicare_primary_TF)%&gt;%\n  \n  #Prepare data for cohort initialization\n  mutate(terminal_date=coalesce(coverage_end_date, censor_date))\n\npatients_merged2&lt;-patients_merged2%&gt;%\n  fc_filter((terminal_date - cryptococcus_dx_date &gt;=minimum_followup) | is.na(cryptococcus_dx_date), \n            label = \"Minimum followup exceeded\", \n            label_exc= \"Excluded: Minimum follow-up threshold not met\",\n            show_exc = TRUE)\n\n  \npatients_merged2%&gt;%\n  fc_draw()"
  },
  {
    "objectID": "quarto/create_cohort.html#creation-of-a-time-varying-cohort",
    "href": "quarto/create_cohort.html#creation-of-a-time-varying-cohort",
    "title": "Create cohort",
    "section": "",
    "text": "We use several functions from the usRds package:\n\ncreate_usrds_cohort()\nadd_cohort_covariate()\nfinalize_usrds_cohort()\n\nThese functions split each patient into multiple rows, with each row describing a discrete period of time. This captures that patients will have time-varying status for covariates such as cirrhosis status, etc.\nPatients with cryptococcus infection join the cohort on the date of cryptococcosis diagnosis, while patients without cryptococcus (potential controls) join on the date of their first kidney transplant.\n“Time since transplant” resets after each new transplant.\n\n\nCode\n#Now we need to construct the time-varying data set\n\n#Ungroup\ninitial_cohort&lt;-patients_merged2$data%&gt;%\n  ungroup()%&gt;%\n\n#Cases join when they experience cryptococcus\n#Controls start on date of first transplant\n  mutate(\n    cohort_join_date = coalesce(\n      as.Date(cryptococcus_dx_date),\n      as.Date(TX1DATE)\n    )\n  )\n\n#Initialize cohort\nprematching_cohort&lt;-create_usrds_cohort(df=initial_cohort,\n                            start_date = \"cohort_join_date\",\n                            end_date = \"terminal_date\")%&gt;%\n  \n  # Add cirrhosis\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"cirrhosis\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"cirrhosis\")%&gt;%\n  \n  # Add CMV\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"CMV\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"CMV\")%&gt;%\n  \n  # Add diabetes\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Diabetes\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"diabetes\")%&gt;%\n  \n  # Add HIV\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"HIV\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"HIV\")%&gt;%\n  \n  # Add liver transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Liver transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"liver_transplant\")%&gt;%\n  \n  # Add lung transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Lung transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"lung_transplant\")%&gt;%\n  \n  # Add heart transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Heart transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"heart_transplant\")%&gt;%\n  \n  # Add pancreas transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Pancreas transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"pancreas_transplant\")%&gt;%\n  \n  # Add heart-lung transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Heart-lung transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"heartlung_transplant\")%&gt;%\n  \n  # Add intestinal transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Intestinal transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"intestinal_transplant\")%&gt;%\n  \n  #Add time-varying information about transplant status\n  add_cohort_covariate(covariate_data_frame=tx_status,\n                       covariate_date=\"event_date\",\n                       covariate_variable_name=\"cumulative_transplant_total\",\n                       covariate_value = \"cumulative_transplant_total\")%&gt;%\n  \n  #Add time-varying information about transplant status (whether current graft is active or failed)\n  add_cohort_covariate(covariate_data_frame=tx_status,\n                       covariate_date=\"event_date\",\n                       covariate_variable_name=\"current_graft_status\",\n                       covariate_value = \"graft_status\")%&gt;%\n  \n  #Add time-varying information about transplant status (date of most recent transplant)\n  add_cohort_covariate(covariate_data_frame=tx_status%&gt;%filter(graft_status==\"Active\"),\n                       covariate_date=\"event_date\",\n                       covariate_variable_name=\"most_recent_transplant_date\",\n                       covariate_value = \"event_date\")%&gt;%\n  \n  #Add time-varying information about transplant status (date of most recent graft failure)\n  add_cohort_covariate(covariate_data_frame=tx_status%&gt;%filter(graft_status==\"Failed\"),\n                       covariate_date=\"event_date\",\n                       covariate_variable_name=\"most_recent_failure_date\",\n                       covariate_value = \"event_date\")%&gt;%\n  \n  # Add Medicare current coverage\n  add_cohort_covariate(covariate_data_frame=medicare_history,\n                       covariate_date=\"BEGDATE\",\n                       covariate_variable_name=\"current_medicare_coverage\",\n                       covariate_value = \"PAYER\"\n                       )%&gt;%\n  \n  finalize_usrds_cohort(baseline_date_variable = \"most_recent_transplant_date\")\n\n\nThe analysis then proceeds on to the execute_matching component."
  },
  {
    "objectID": "quarto/execute_matching.html#prepare-cohort-for-matching",
    "href": "quarto/execute_matching.html#prepare-cohort-for-matching",
    "title": "Execute matching",
    "section": "",
    "text": "The following code prepares the cohort for matching by creating a list object unmatched_patients, keeping only the initial row for each case as only the covariates at the time of cryptococcus are necessary for matching.\n\n\nCode\nunmatched_patients&lt;-list()\n\nunmatched_patients[[\"Case\"]]&lt;-prematching_cohort%&gt;%\n  filter(cryptococcus_case==\"Case\")\n\nunmatched_patients[[\"Control\"]]&lt;-prematching_cohort%&gt;%\n  filter(cryptococcus_case==\"Potential control\")\n\nunmatched_patients[[\"Case\"]]&lt;-unmatched_patients[[\"Case\"]]%&gt;%\n  group_by(USRDS_ID)%&gt;%\n  slice(1)%&gt;%\n  ungroup()\n\n#For exploration--perhaps can delete in future?\nCase&lt;-unmatched_patients[[\"Case\"]]\nControl&lt;-unmatched_patients[[\"Control\"]]"
  },
  {
    "objectID": "quarto/execute_matching.html#counting-the-potental-number-of-matched-controls-for-each-case",
    "href": "quarto/execute_matching.html#counting-the-potental-number-of-matched-controls-for-each-case",
    "title": "Execute matching",
    "section": "",
    "text": "This step uses the calculate_number_potential_matches() function defined in the R/functions.R to add a column to the cases data set, then sorts the cases so that those with the lowest number of potential matches are matched first.\n(Note the following code took ~2 hours to execute on a laptop given the size of the dataset.)\n\n\nCode\n#Add number of potential control matches to Case df\nunmatched_patients[[\"Case\"]] &lt;- unmatched_patients[[\"Case\"]] %&gt;%\n  mutate(\n    num_potential_controls = pmap_int(\n      list(USRDS_ID, BORN,cirrhosis, CMV, HIV, diabetes, cryptococcus_dx_date, tstart),\n      function(USRDS_ID, BORN, cirrhosis, CMV, HIV, diabetes, matching_date, tstart) {\n        calculate_number_potential_matches(\n          unmatched_patients[[\"Control\"]],\n          USRDS_ID,\n          BORN, \n          cirrhosis,\n          CMV,\n          HIV,\n          diabetes,\n          matching_date,\n          tstart\n        )\n      }\n    )\n  )\n\n#Sort by number of potential matches so that most difficult to match cases are matched first\n#Set the index_date for cases to be the date of cryptococcus dx\nunmatched_patients[[\"Case\"]] &lt;- unmatched_patients[[\"Case\"]] %&gt;%\n  arrange(num_potential_controls)%&gt;%\n  mutate(index_date_match=cryptococcus_dx_date)\n\n\n#Can be deleted\nunmatched_patients_backup&lt;-unmatched_patients\nunmatched_patients&lt;-unmatched_patients_backup"
  },
  {
    "objectID": "quarto/execute_matching.html#create-a-matched-data-set",
    "href": "quarto/execute_matching.html#create-a-matched-data-set",
    "title": "Execute matching",
    "section": "",
    "text": "The following code executes the match, creating a matched dataframe suitable for use in subsequent analysis.\n\n\nCode\n#Time to set up the matching loop\n\n#Initial the loop control\ncontinue&lt;-TRUE\ni&lt;-0\nset.seed(12345)\n\n#Initialize the object where the matched cases and controls will be stored\nmatched_patients&lt;-list()\nmatched_patients[[\"Case\"]]&lt;-unmatched_patients[[\"Case\"]][0, ]%&gt;%\n  mutate(matched_control_indices = list())\nmatched_patients[[\"Control\"]] &lt;- unmatched_patients[[\"Control\"]][0, ] %&gt;%\n  mutate(index_date_match = as.Date(character()))\n\n\n#Perform the match\nwhile (continue==TRUE)\n{\n  i&lt;-i+1\n  print(i)\n\n  #Select matches from controls\n  eligible_controls &lt;-unmatched_patients[[\"Control\"]]%&gt;%\n    \n    filter(cirrhosis==unmatched_patients$Case$cirrhosis[[1]])%&gt;%\n    #filter(CMV==unmatched_patients$Case$CMV[[1]])%&gt;%\n    filter(HIV==unmatched_patients$Case$HIV[[1]])%&gt;%\n    filter(diabetes==unmatched_patients$Case$diabetes[[1]])%&gt;%\n    \n    #Risk set matching\n    filter(tstart&lt;=unmatched_patients$Case$tstart[[1]])%&gt;%\n    filter(tstop&gt;unmatched_patients$Case$tstart[[1]])%&gt;%\n    \n    #Calculate date for age calculations/etc.\n    mutate(.baseline_control_date=unmatched_patients$Case$tstart[[1]] + most_recent_transplant_date)%&gt;%\n    \n    #Make sure case and control are sampled within 3 years of each other\n    filter(abs(time_length(interval(.baseline_control_date, unmatched_patients$Case$cryptococcus_dx_date[[1]]), \"years\")) &lt;=3)%&gt;%\n    \n    #filter(cohort_start_date&lt;=unmatched_patients$Case$cryptococcus_dx_date[[1]])%&gt;%\n    #filter(cohort_stop_date&gt;unmatched_patients$Case$cryptococcus_dx_date[[1]])%&gt;%\n    \n    #Age&gt;=18 on index date\n    filter(time_length(interval(BORN, .baseline_control_date), \"years\") &gt;= 18)%&gt;%\n    \n    #Age difference under 10 years, calculated at sampling date\n    filter(abs(time_length(interval(BORN,.baseline_control_date), \"years\")-\n                 time_length(interval(unmatched_patients$Case$BORN[[1]],\n                                      unmatched_patients$Case$cryptococcus_dx_date[[1]]), \"years\")) &lt;=10)%&gt;%\n  \n    verify_medicare_primary(index_date = \".baseline_control_date\", \n                            medicare_coverage_df = medicare_history, \n                            coverage_start_variable = \"medicare_coverage_start_date\",\n                            coverage_end_variable = \"medicare_coverage_end_date\",\n                            cache=TRUE)%&gt;%\n    filter(medicare_primary_TF==TRUE)%&gt;%\n    \n    #Move matches for cumulative number of transplants to the top\n    #Note: this step could be used for propensity score matching on various variables\n    #Consider minimizing date difference and age difference as well\n    arrange(desc(cumulative_transplant_total==unmatched_patients$Case$cumulative_transplant_total[[1]]))\n  \n  \n  #Number of controls is minimum of global constant number_controls_per_case and number of distinct USRDS_IDs\n  k &lt;- min(number_controls_per_case, nrow(distinct(eligible_controls, USRDS_ID)))\n  \n  #Initialize sampled_controls df\n  sampled_controls&lt;-eligible_controls[0, ]\n    \n  #Loop to select controls one at a time to ensure same patient is not sampled multiple times \n  while (k&gt;0)\n  {\n  \n  sampled_controls &lt;- bind_rows(\n    sampled_controls,\n    eligible_controls %&gt;%slice_head(n = 1))\n    \n    eligible_controls&lt;-eligible_controls%&gt;%\n      filter(!(USRDS_ID %in% sampled_controls$USRDS_ID ))\n\n    k&lt;-min(k-1, nrow(distinct(eligible_controls, USRDS_ID)))   \n  }\n    \n    sampled_controls&lt;-sampled_controls%&gt;%\n    mutate(index_date_match = .baseline_control_date)%&gt;%\n    select(-.baseline_control_date)\n  \n  #Add case to matched DF\n  matched_patients[[\"Case\"]]&lt;-unmatched_patients$Case[1,]%&gt;%\n    mutate(matched_control_indices=list(sampled_controls$USRDS_ID))%&gt;%\n    bind_rows(matched_patients[[\"Case\"]])\n  \n  #Add controls to control DF\n  matched_patients[[\"Control\"]]&lt;-matched_patients[[\"Control\"]]%&gt;%\n    bind_rows(sampled_controls)\n  \n  #Remove controls\n  unmatched_patients[[\"Control\"]]&lt;-unmatched_patients[[\"Control\"]]%&gt;%\n    filter(!(USRDS_ID %in% sampled_controls$USRDS_ID ))\n  \n  #Remove cases\n  unmatched_patients[[\"Case\"]]&lt;-unmatched_patients[[\"Case\"]]%&gt;%\n    slice(-1)\n  \n if (nrow(unmatched_patients[[\"Case\"]])==0){\n   continue&lt;-FALSE\n } \n  \n  if (i==10000){\n    continue&lt;-FALSE\n  }\n  \n}\n\n\npost_match_results&lt;-matched_patients%&gt;%\n  bind_rows(.id = \"patient_type\")\n\n\nThe modeling script uses the above matched dataframe for the actual cost analysis."
  },
  {
    "objectID": "quarto/postmatch_processing.html#cohort-flow-diagram-after-risk-set-matching",
    "href": "quarto/postmatch_processing.html#cohort-flow-diagram-after-risk-set-matching",
    "title": "Post-match processing",
    "section": "Cohort flow diagram after risk-set matching",
    "text": "Cohort flow diagram after risk-set matching\nWe update the cohort flow diagram to reflect the results of the risk-set matching procedure, indicating which patients were retained as matched cases or controls and which were excluded due to lack of suitable matches.\n\n\nCode\n#Update flowchart to reflect matching process\npatients_fc_matched&lt;-patients_merged2%&gt;%\n  fc_filter(USRDS_ID %in% post_match_results$USRDS_ID,\n            label = \"Matched\", \n            label_exc= \"Excluded: Unmatched\",\n            show_exc = TRUE)\n\npatients_fc_matched%&gt;%\n  fc_draw()"
  },
  {
    "objectID": "quarto/postmatch_processing.html#obtain-raw-costs-from-raw-claims-data",
    "href": "quarto/postmatch_processing.html#obtain-raw-costs-from-raw-claims-data",
    "title": "Post-match processing",
    "section": "Obtain raw costs from raw claims data",
    "text": "Obtain raw costs from raw claims data\nWe use the get_IN_REV_costs(), get_IN_CLM_costs(), and get_PS_REV_costs() functions to extract raw Medicare claims with cost information for patients in the matched cohort.\nMedicare claims data are organized into claim-level (CLM) files and revenue center (REV) files, which differ in their level of aggregation. CLM files summarize costs at the claim level, while REV files contain detailed line-item charges associated with individual services within a claim.\nFor example, a home health agency may submit a single claim covering a multi-day episode of care. This episode appears as one row in a CLM file and as multiple rows in the corresponding REV file, reflecting individual billed services. As a result, costs from CLM and REV files for the same service year should not be summed, as this would lead to double counting.\nFor inpatient (Part A) services, Medicare reimbursement is based on diagnosis-related groups (DRGs), and itemized line-item billing is not permitted. Accordingly, inpatient costs are obtained exclusively from CLM files, which capture the full reimbursed amount for each inpatient stay.\nFor physician/supplier (Part B) services, claim-level CLM files are not available prior to 2012 in the USRDS. Therefore, revenue center files are used to capture physician/supplier-related costs for earlier years.\nThese distinctions follow standard guidance in the USRDS Researcher’s Guide and CMS Medicare billing documentation.\n\n\nCode\n#Gather raw costs for each patient\ncosts_raw&lt;-list()\ncosts_raw[[\"IN_REV\"]]&lt;-get_IN_REV_costs(years = 2006:2021, usrds_ids = post_match_results$USRDS_ID)\ncosts_raw[[\"IN_CLM\"]]&lt;-get_IN_CLM_costs(years = 2006:2021, usrds_ids = post_match_results$USRDS_ID)\ncosts_raw[[\"PS_REV\"]]&lt;-get_PS_REV_costs(years = 2006:2021, usrds_ids = post_match_results$USRDS_ID)"
  },
  {
    "objectID": "quarto/postmatch_processing.html#merge-cost-data-to-cohort",
    "href": "quarto/postmatch_processing.html#merge-cost-data-to-cohort",
    "title": "Post-match processing",
    "section": "Merge cost data to cohort",
    "text": "Merge cost data to cohort\nWe take the raw claims data and add it to the previously obtained patient cohort data.\nThis is done as a nested data frame for convenience in subsequent analysis. A single column is a list, which each element of the list being all cost-related entries for a specific patient. See https://bookdown.org/Maxine/r4ds/nesting.html for more information on nested data in R.\nPatients with no observed claims in a given cost category are assigned empty tibbles to ensure consistent downstream processing.\nThis structure allows costs to be prorated, inflated, and aggregated relative to patient-specific index dates without repeatedly reshaping the data.\nWhile nested data is convenient from many perspectives, it does require the use of the map() family of functions from the purrr package.\n\n\nCode\n#Group by ID and nest, so that each patient has a single tibble for each type of cost\n#Start with the raw costs\ncosts_clean &lt;- costs_raw%&gt;% \n  \n  #Use the imap function to create nested tibbles so that each USRDS ID is unique\n  imap(~.x %&gt;%\n         group_by(USRDS_ID) %&gt;%\n         nest(!!paste0(.y, \"_rows\") := -USRDS_ID)\n  )%&gt;%\n  \n  #Join the three tibbles in the resulting list\n  reduce(full_join, by = \"USRDS_ID\")%&gt;%\n  \n  #Clean up so that patients with empty cost data tibbles do not throw an error later by providing empty columns\n  mutate(IN_REV_rows=replace_na(IN_REV_rows, list(tibble(CLM_FROM = as.Date(character()),\n                                                         REV_CH = numeric(),\n                                                         REVPMT = numeric(),\n                                                         HCFASAF = character()))))%&gt;%\n  mutate(IN_CLM_rows=replace_na(IN_CLM_rows, list(tibble(CLM_FROM = as.Date(character()),\n                                                         CLM_THRU = as.Date(character()),\n                                                         CLM_TOT = numeric(),\n                                                         CLM_AMT = numeric(),\n                                                         HCFASAF = character()))))%&gt;%\n  mutate(PS_REV_rows=replace_na(PS_REV_rows, list(tibble(CLM_FROM = as.Date(character()),\n                                                         CLM_THRU = as.Date(character()),\n                                                         SBMTCH = numeric(),\n                                                         ALOWCH = numeric(),\n                                                         PMTAMT = numeric(),\n                                                         HCFASAF = character()))))\n\n\n\n#Add cost tibbles to patients_clean data set\ncost_joined&lt;-left_join(post_match_results, \n                       costs_clean, \n                       by = join_by(USRDS_ID))%&gt;%\n  mutate(IN_REV_rows=map(IN_REV_rows, ~ if (is.null(.x)) tibble(CLM_FROM = as.Date(character()),\n                                                                REV_CH = numeric(),\n                                                                REVPMT = numeric(),\n                                                                HCFASAF = character()) else .x))%&gt;%\n  mutate(IN_CLM_rows=map(IN_CLM_rows, ~ if (is.null(.x)) tibble(CLM_FROM = as.Date(character()),\n                                                                CLM_THRU = as.Date(character()),\n                                                                CLM_TOT = numeric(),\n                                                                CLM_AMT = numeric(),\n                                                                HCFASAF = character()) else .x))%&gt;%\n  mutate(PS_REV_rows=map(PS_REV_rows, ~ if (is.null(.x)) tibble(CLM_FROM = as.Date(character()),\n                                                                CLM_THRU = as.Date(character()),\n                                                                SBMTCH = numeric(),\n                                                                ALOWCH = numeric(),\n                                                                PMTAMT = numeric(),\n                                                                HCFASAF = character()) else .x))"
  },
  {
    "objectID": "quarto/postmatch_processing.html#totalling-costs",
    "href": "quarto/postmatch_processing.html#totalling-costs",
    "title": "Post-match processing",
    "section": "Totalling costs",
    "text": "Totalling costs\nWe start by testing the data frame to make sure that the analysis worked by writing appropriate code to calculate all costs in the USRDS for each patient, starting from the index date. This is for validation only and is not used for modeling.\n\n\nCode\n#Use the cost claims to calculate appropriate\ncost_intermediate&lt;-cost_joined%&gt;%\n  mutate(IN_REV_post_cost = map2_dbl(IN_REV_rows, index_date_match, ~\n                                      .x %&gt;%\n                                      filter(CLM_FROM &gt;= .y)%&gt;%\n                                      summarise(total = sum(REVPMT, na.rm = TRUE)) %&gt;%\n                                      pull(total)\n  ))%&gt;%\n  mutate(IN_CLM_post_cost = map2_dbl(IN_CLM_rows, index_date_match, ~\n                                      .x %&gt;%\n                                      filter(CLM_FROM &gt;= .y)%&gt;%\n                                      summarise(total = sum(CLM_AMT, na.rm = TRUE)) %&gt;%\n                                      pull(total)\n  ))%&gt;%\n  mutate(PS_REV_post_cost = map2_dbl(PS_REV_rows, index_date_match, ~\n                                      .x %&gt;%\n                                      filter(CLM_FROM &gt;= .y)%&gt;%\n                                      summarise(total = sum(PMTAMT, na.rm = TRUE)) %&gt;%\n                                      pull(total)\n  ))"
  },
  {
    "objectID": "quarto/postmatch_processing.html#costs-from-start-date-to-end-date",
    "href": "quarto/postmatch_processing.html#costs-from-start-date-to-end-date",
    "title": "Post-match processing",
    "section": "Costs from start date to end date",
    "text": "Costs from start date to end date\nWe now write code that totals costs for each patient, accounting for the start and finish dates:\n\nStart: The index date for each patient\nFinish: The earliest of\n\nEnd of Medicare coverage (minimum 1 day)\nDeath\nCensoring date for end of data (1/1/2022)\n\n\nIn addition to total costs, we also calculated total costs grouped by type (Inpatient, Outpatient, Home Health, etc.).\nSince claims can span many days, we use the prorate_costs_by_day() function from the usrds package to divide the costs evenly among the days spanned by each claim. Proration is applied before date filtering so that only the portion of each claim overlapping the analytic window contributes to total cost.\n\n\nCode\n#Now we trial code that accounts for both the start date and the end date\ncost_broken_down&lt;-cost_intermediate%&gt;%\n  \n  #Define end date for purposes of cost using maximum_followup from setup file\n  mutate(end_date_analysis=pmin(index_date_match + maximum_followup,\n                                censor_date,\n                                coverage_end_date,\n                                medicare_coverage_end_date,\n                                na.rm=TRUE\n                                ))%&gt;%\n  \n  mutate(duration_cost_followup=time_length(interval(index_date_match, end_date_analysis), \"days\"))%&gt;%\n  mutate(follow_up_final_event=case_when(\n    end_date_analysis==DIED ~ \"Death\",\n    end_date_analysis==index_date_match + maximum_followup ~ \"Maximum follow-up\",\n    end_date_analysis==censor_date ~ \"Censored\",\n    end_date_analysis==coverage_end_date | end_date_analysis==medicare_coverage_end_date ~ \"Loss of coverage\"\n  ))%&gt;%\n  \n  #Use pmap_dbl to calculate costs between first_cryptococcus_date and end_date for IN_REV\n  mutate(IN_REV_365d_cost_total=pmap_dbl(\n    .l=list(IN_REV_rows, index_date_match, end_date_analysis),\n    .f=function(claims_df, s_date,e_date) {\n      claims_df%&gt;%\n        filter(CLM_FROM &gt;= s_date, CLM_FROM&lt;=e_date)%&gt;%\n        summarise(total = sum(REVPMT, na.rm = TRUE)) %&gt;%\n        pull(total)}\n  )\n  )%&gt;%\n  \n  #Same, except now we group by HCFASAF\n  #Use pmap to calculate costs between first_cryptococcus_date and end_date for IN_REV, grouped by HCFASAF\n  mutate(IN_REV_365d_cost_grouped=pmap(\n    .l=list(IN_REV_rows, index_date_match, end_date_analysis),\n    .f=function(claims_df, s_date,e_date) {\n      claims_df%&gt;%\n        filter(CLM_FROM &gt;= s_date, CLM_FROM&lt;=e_date)%&gt;%\n        mutate(HCFASAF = stringr::str_replace_all(HCFASAF, \" \", \"\"))%&gt;%\n        mutate(HCFASAF = ifelse(HCFASAF==\"Inpatient(REBUS)\", \"Inpatient\", HCFASAF))%&gt;%\n        mutate(HCFASAF = ifelse(HCFASAF==\"Non-claim/auxiliary\", \"Nonclaimauxiliary\", HCFASAF))%&gt;%\n        group_by(HCFASAF)%&gt;%\n        summarise(total = sum(REVPMT, na.rm = TRUE)) %&gt;%\n        pivot_wider(\n          names_from  = HCFASAF,\n          values_from = total,\n          names_prefix = \"IN_REV_365d_cost_\",\n          values_fill = 0\n        ) \n      }\n  )\n  )%&gt;%\n  \n  #Use pmap_dbl to calculate costs between first_cryptococcus_date and end_date for IN_CLM, after prorating costs by day\n  mutate(IN_CLM_365d_cost_total=pmap_dbl(\n    .l=list(IN_CLM_rows, index_date_match, end_date_analysis),\n    .f=function(claims_df, s_date,e_date) {\n      claims_df%&gt;%\n        usRds::prorate_costs_by_day()%&gt;%\n        filter(CLM_FROM &gt;= s_date, CLM_FROM&lt;=e_date)%&gt;%\n        summarise(total = sum(CLM_AMT_PRORATED, na.rm = TRUE))%&gt;%\n        pull(total)\n    }\n      )\n  )%&gt;%\n  \n  \n  #Same, except now we group by HCFASAF\n  #Use pmap to calculate costs between first_cryptococcus_date and end_date for IN_CLM, after prorating costs by day\n  mutate(IN_CLM_365d_cost_grouped=pmap(\n    .l=list(IN_CLM_rows, index_date_match, end_date_analysis),\n    .f=function(claims_df, s_date,e_date) {\n      claims_df%&gt;%\n        usRds::prorate_costs_by_day()%&gt;%\n        filter(CLM_FROM &gt;= s_date, CLM_FROM&lt;=e_date)%&gt;%\n        mutate(HCFASAF = stringr::str_replace_all(HCFASAF, \" \", \"\"))%&gt;%\n        mutate(HCFASAF = ifelse(HCFASAF==\"Inpatient(REBUS)\", \"Inpatient\", HCFASAF))%&gt;%\n        mutate(HCFASAF = ifelse(HCFASAF==\"Non-claim/auxiliary\", \"Nonclaimauxiliary\", HCFASAF))%&gt;%\n        group_by(HCFASAF)%&gt;%\n        summarise(total = sum(CLM_AMT_PRORATED, na.rm = TRUE))%&gt;%\n        pivot_wider(\n          names_from  = HCFASAF,\n          values_from = total,\n          names_prefix = \"IN_CLM_365d_cost_\",\n          values_fill = 0\n        ) \n    }\n  )\n  )%&gt;%\n  \n  \n  #Use pmap_dbl to calculate costs between first_cryptococcus_date and end_date for PS_REV\n  mutate(PS_REV_365d_cost_total=pmap_dbl(\n    .l=list(PS_REV_rows, index_date_match, end_date_analysis),\n    .f=function(claims_df, s_date,e_date) {\n      claims_df%&gt;%\n        filter(CLM_FROM &gt;= s_date, CLM_FROM&lt;=e_date)%&gt;%\n        summarise(total = sum(PMTAMT, na.rm = TRUE)) %&gt;%\n        pull(total)}\n  )\n  )%&gt;%\n  \n  unnest_wider(IN_REV_365d_cost_grouped)%&gt;%\n  unnest_wider(IN_CLM_365d_cost_grouped)%&gt;%\n  mutate(across(matches(\"_365d_cost_\"), ~replace_na(., 0)))"
  },
  {
    "objectID": "quarto/postmatch_processing.html#accounting-for-inflation",
    "href": "quarto/postmatch_processing.html#accounting-for-inflation",
    "title": "Post-match processing",
    "section": "Accounting for inflation",
    "text": "Accounting for inflation\nWe repeat the analysis above, except that we use the adjust_costs_for_inflation() function from the usRds package to adjust costs for medical inflation, using the month and year listed in the R/setup.R file to establish the time point at which all costs are anchored based on the medical Consumer Price Index.\n\n\nCode\ncost_inflated&lt;-\n  cost_broken_down%&gt;%\n  \n  #Use pmap_dbl to calculate costs between first_cryptococcus_date and end_date for IN_REV\n  mutate(IN_REV_365d_cost_adjusted_total=pmap_dbl(\n    .l=list(IN_REV_rows, index_date_match, end_date_analysis),\n    .f=function(claims_df, s_date,e_date) {\n      claims_df%&gt;%\n        filter(CLM_FROM &gt;= s_date, CLM_FROM&lt;=e_date)%&gt;%\n        adjust_costs_for_inflation(baseline_month = inflation_month, baseline_year = inflation_year)%&gt;%\n        summarise(total = sum(REVPMT_ADJUSTED, na.rm = TRUE)) %&gt;%\n        pull(total)}\n  )\n  )%&gt;%\n  \n  #Use pmap_dbl to calculate costs between first_cryptococcus_date and end_date for IN_CLM, after prorating costs by day and inflating\n  mutate(IN_CLM_365d_cost_adjusted_total=pmap_dbl(\n    .l=list(IN_CLM_rows, index_date_match, end_date_analysis),\n    .f=function(claims_df, s_date,e_date) {\n      claims_df%&gt;%\n        usRds::prorate_costs_by_day()%&gt;%\n        adjust_costs_for_inflation(baseline_month = inflation_month, baseline_year = inflation_year)%&gt;%\n        filter(CLM_FROM &gt;= s_date, CLM_FROM&lt;=e_date)%&gt;%\n        summarise(total = sum(CLM_AMT_PRORATED_ADJUSTED, na.rm = TRUE))%&gt;%\n        pull(total)\n    }\n  )\n  )%&gt;%\n  \n  #Use pmap_dbl to calculate costs between first_cryptococcus_date and end_date for PS_REV\n  mutate(PS_REV_365d_cost_adjusted_total=pmap_dbl(\n    .l=list(PS_REV_rows, index_date_match, end_date_analysis),\n    .f=function(claims_df, s_date,e_date) {\n      claims_df%&gt;%\n        filter(CLM_FROM &gt;= s_date, CLM_FROM&lt;=e_date)%&gt;%\n        adjust_costs_for_inflation(baseline_month = inflation_month, baseline_year = inflation_year)%&gt;%\n        summarise(total = sum(PMTAMT_ADJUSTED, na.rm = TRUE)) %&gt;%\n        pull(total)}\n  )\n  )%&gt;%\n  \n  #Same, except now we group by HCFASAF\n  #Use pmap to calculate costs between first_cryptococcus_date and end_date for IN_CLM, after prorating costs by day\n  mutate(IN_CLM_365d_cost_adjusted_grouped=pmap(\n    .l=list(IN_CLM_rows, index_date_match, end_date_analysis),\n    .f=function(claims_df, s_date,e_date) {\n      claims_df%&gt;%\n        usRds::prorate_costs_by_day()%&gt;%\n        adjust_costs_for_inflation(baseline_month = inflation_month, baseline_year = inflation_year)%&gt;%\n        filter(CLM_FROM &gt;= s_date, CLM_FROM&lt;=e_date)%&gt;%\n        mutate(HCFASAF = stringr::str_replace_all(HCFASAF, \" \", \"\"))%&gt;%\n        mutate(HCFASAF = ifelse(HCFASAF==\"Inpatient(REBUS)\", \"Inpatient\", HCFASAF))%&gt;%\n        mutate(HCFASAF = ifelse(HCFASAF==\"Non-claim/auxiliary\", \"Nonclaimauxiliary\", HCFASAF))%&gt;%\n        group_by(HCFASAF)%&gt;%\n        summarise(total = sum(CLM_AMT_PRORATED_ADJUSTED, na.rm = TRUE))%&gt;%\n        pivot_wider(\n          names_from  = HCFASAF,\n          values_from = total,\n          names_prefix = \"IN_CLM_365d_cost_adjusted\",\n          values_fill = 0\n        ) \n    }\n  )\n  )%&gt;%\n  unnest_wider(IN_CLM_365d_cost_adjusted_grouped)%&gt;%\n  mutate(across(matches(\"_365d_cost_\"), ~replace_na(., 0)))"
  },
  {
    "objectID": "quarto/postmatch_processing.html#grouping-by-month",
    "href": "quarto/postmatch_processing.html#grouping-by-month",
    "title": "Post-match processing",
    "section": "Grouping by month",
    "text": "Grouping by month\nIn order to model costs appropriately, we group costs for each patient into 30-day increments, starting from the beginning of the look-back period defined in the R/setup.R file. This will allow us to estimate full-year costs for patients who lose their coverage or are censored before the end of a full-year but do not experience death.\n\n\nCode\n  #Longitudinal data set for modeling\ncost_longitudinal&lt;-\n  cost_inflated%&gt;%\n\n  #Use pmap to calculate costs between first_cryptococcus_date and end_date for IN_CLM, after prorating costs by day and inflating\n  mutate(IN_CLM_365d_cost_adjusted_total_longitudinal=pmap(\n    .l=list(IN_CLM_rows, index_date_match, end_date_analysis),\n    .f=function(claims_df, s_date,e_date) {\n      claims_df%&gt;%\n        usRds::prorate_costs_by_day()%&gt;%\n        adjust_costs_for_inflation(baseline_month = inflation_month, baseline_year = inflation_year)%&gt;%\n        filter(service_date &gt;= s_date-30*baseline_months_cost, service_date&lt;=e_date)%&gt;%\n        mutate(month=time_length(interval(s_date, service_date), \"days\") %/% 30)%&gt;%\n        filter(month&lt;12)%&gt;%\n        group_by(month)%&gt;%\n        summarise(IN_CLM_month_total = sum(CLM_AMT_PRORATED_ADJUSTED, na.rm = TRUE), \n                  .groups = \"drop\")%&gt;%\n        mutate(IN_CLM_month_total=pmax(IN_CLM_month_total,0))%&gt;%\n        ungroup()%&gt;%\n        tidyr::complete(\n          month = full_months\n        )\n    }\n  )\n  )%&gt;%\n\n  #Use pmap to calculate costs between first_cryptococcus_date and end_date for PS_REV\n  mutate(PS_REV_365d_cost_adjusted_total_longitudinal=pmap(\n    .l=list(PS_REV_rows, index_date_match, end_date_analysis),\n    .f=function(claims_df, s_date,e_date) {\n      claims_df%&gt;%\n        filter(CLM_FROM &gt;= s_date-30*baseline_months_cost, CLM_FROM&lt;=e_date)%&gt;%\n        adjust_costs_for_inflation(baseline_month = inflation_month, baseline_year = inflation_year)%&gt;%\n        mutate(month=time_length(interval(s_date, CLM_FROM), \"days\") %/% 30)%&gt;%\n        filter(month&lt;12)%&gt;%\n        group_by(month)%&gt;%\n        summarise(PS_REV_month_total = sum(PMTAMT_ADJUSTED, na.rm = TRUE), \n                  .groups = \"drop\") %&gt;%\n        mutate(PS_REV_month_total=pmax(PS_REV_month_total,0))%&gt;%\n        ungroup()\n    }\n        \n        \n  )\n  )%&gt;%\n\n  #IN_CLM, except now we group by HCFASAF\n  #Use pmap to calculate costs IN_CLM, after prorating costs by day\n  mutate(IN_CLM_365d_cost_adjusted_grouped_longitudinal=pmap(\n    .l=list(IN_CLM_rows, index_date_match, end_date_analysis),\n    .f=function(claims_df, s_date,e_date) {\n      claims_df%&gt;%\n        usRds::prorate_costs_by_day()%&gt;%\n        adjust_costs_for_inflation(baseline_month = inflation_month, baseline_year = inflation_year)%&gt;%\n        filter(service_date &gt;= s_date-30*baseline_months_cost, service_date&lt;=e_date)%&gt;%\n        mutate(month=time_length(interval(s_date, service_date), \"days\") %/% 30)%&gt;%\n        filter(month&lt;12)%&gt;%\n        mutate(HCFASAF = stringr::str_replace_all(HCFASAF, \" \", \"\"))%&gt;%\n        mutate(HCFASAF = ifelse(HCFASAF==\"Inpatient(REBUS)\", \"Inpatient\", HCFASAF))%&gt;%\n        mutate(HCFASAF = ifelse(HCFASAF==\"Non-claim/auxiliary\", \"Nonclaimauxiliary\", HCFASAF))%&gt;%\n        group_by(month, HCFASAF)%&gt;%\n        summarise(total = sum(CLM_AMT_PRORATED_ADJUSTED, na.rm = TRUE), \n                  .groups = \"drop\")%&gt;%\n        mutate(total=pmax(total,0))%&gt;%\n        pivot_wider(\n          names_from  = HCFASAF,\n          values_from = total,\n          names_prefix = \"IN_CLM_month_grouped\",\n          values_fill = 0\n        ) \n    }\n  )\n  )%&gt;%\n  mutate(\n    cost_column_longitudinal = pmap(\n      list(\n        IN_CLM_365d_cost_adjusted_total_longitudinal,\n        PS_REV_365d_cost_adjusted_total_longitudinal,\n        IN_CLM_365d_cost_adjusted_grouped_longitudinal,\n        index_date_match, \n        end_date_analysis\n      ),\n      ~ left_join(..1, ..2, by = \"month\") %&gt;%\n        left_join(..3, by = \"month\")%&gt;%\n        mutate(month_offset=pmin(30, time_length(interval(..4, ..5), \"days\")-30*month + 1 ))%&gt;%\n        mutate(month_offset=pmax(month_offset,0))\n\n    ))%&gt;%\n  select(-IN_CLM_365d_cost_adjusted_total_longitudinal,\n         -PS_REV_365d_cost_adjusted_total_longitudinal,\n         -IN_CLM_365d_cost_adjusted_grouped_longitudinal)%&gt;%\n  unnest(cost_column_longitudinal)%&gt;%\n  mutate(\n    patient_type = factor(patient_type),\n    patient_type = relevel(patient_type, ref = \"Control\")\n  )%&gt;%\n  \n  mutate(across(\n    c(\n      IN_CLM_month_total,\n      PS_REV_month_total,\n      starts_with(\"IN_CLM_month_grouped\")\n    ),\n    ~replace_na(., 0)))%&gt;%\n  mutate(grand_total_cost_month=IN_CLM_month_total+PS_REV_month_total)"
  },
  {
    "objectID": "quarto/postmatch_processing.html#final-preparation",
    "href": "quarto/postmatch_processing.html#final-preparation",
    "title": "Post-match processing",
    "section": "Final preparation",
    "text": "Final preparation\nWe prepare a final data-set for modeling from the monthly data set by removing the granular cost data and removing months where the patients are not under observation. We also create a dataframe with the number of patients under observation in each month from the beginning of the lookup period to the end of follow-up.\n\n\nCode\n#Remove lists-columns from the final data frame since they are space-consuming and clunky, and remove months where the patient is not under observation\nfinal_data_set&lt;-cost_longitudinal%&gt;%\n  select(where(~ !is.list(.)))%&gt;%\n  filter(month_offset&gt;0)\n\n#create a data frame for use as a risk table in ggplot\nfinal_count_df&lt;-final_data_set%&gt;%\n  count(patient_type, month)\n\n\nThe resulting data frames are used in the R/modeling.R, R/tables.R, and R/figures.R scripts."
  },
  {
    "objectID": "quarto/modeling.html#longitudinal-cost-data-models",
    "href": "quarto/modeling.html#longitudinal-cost-data-models",
    "title": "Modeling",
    "section": "Longitudinal cost data models",
    "text": "Longitudinal cost data models\nThe following code runs models on the following outcomes as generated by the files in the R/postmatch_processing.R file, to calculate costs per month:\n\nTotal costs\nPhysician/supplier costs\nInstitutional total claims costs\nInstitutional Home Health costs\nInstitutional Inpatient costs\nInstitutional Outpatient costs\nInstitutional Skilled Nursing Facility costs\nInstitutional Dialysis costs\nInstitutional Auxiliary costs\nInstitutional Hospice costs\nInstitutional Home Health costs\n\nAnalyzing cost data is notoriously challenging. While guides exist online, experts have also devoted entire books to the topic.\nTo account for the repeated-observations nature of the data, both generalized estimating equations as well as mixed-effects models with patient as a random effect were explored.\nModeling cost data is challenging due to the highly skewed nature of medical cost data. We explored linear models, log(Cost) models, and Tweedie models.\nAccounting for missingness and censoring of costs due to lack of coverage and death is itself a challenging topic, covered well in a recent review. Seminal papers have been written by:\n\nLin et al\nBang et al\n\nWe trialed multiple types of models:\n\nNaive estimation (patients do not contribute observations if uncovered or dead)\nTreating post-death costs as zero, ignoring months with costs uncovered (note: not done yet)\nTreating post-death costs as zero, weighting to adjust for uncovered months (note: not done yet)\n\n\n\nCode\n# Statistical modeling of cost data\n\nfor (outcome in c(\"grand_total_cost_month\", \"IN_CLM_month_total\", \"PS_REV_month_total\", \"IN_CLM_month_groupedHomeHealth\",\n                  \"IN_CLM_month_groupedHospice\",\"IN_CLM_month_groupedNonclaimauxiliary\",\"IN_CLM_month_groupedDialysis\",\n                  \"IN_CLM_month_groupedOutpatient\",\"IN_CLM_month_groupedInpatient\",\"IN_CLM_month_groupedSkilledNursingFacility\")){\n\n  temp_formula[[\"glmmTMB\"]][[\"untransformed\"]]&lt;-as.formula(\n    paste0(\n      outcome, \" ~ \",\n      \"patient_type * factor(month) + \",\n      \"offset(log(month_offset)) + \",\n      \"(1 | USRDS_ID)\"\n    )\n  )\n  temp_formula[[\"gee\"]][[\"untransformed\"]]&lt;-as.formula(\n    paste0(\n      outcome, \" ~ \",\n      \"patient_type * factor(month) + \",\n      \"offset(log(month_offset))\"\n    )\n  )\n\n  temp_formula[[\"glmmTMB\"]][[\"logtransformed\"]] &lt;- as.formula(\n    paste0(\n      \"log1p(\", outcome, \") ~ \",\n      \"patient_type * factor(month) + \",\n      \"offset(log(month_offset)) + \",\n      \"(1 | USRDS_ID)\"\n    )\n  )\n  temp_formula[[\"gee\"]][[\"logtransformed\"]]&lt;-as.formula(\n    paste0(\n      \"log1p(\", outcome, \") ~ \",\n      \"patient_type * factor(month) + \",\n      \"offset(log(month_offset))\"\n    )\n  )\n  \n  message(\n    \"Fitting models to formula: \", temp_formula[[\"glmmTMB\"]][[\"untransformed\"]]\n  )\n  \n  message(\"Fitting glmmTMB to tweedie family...\")\n  fit[[outcome]][[\"glmmTMB\"]][[\"tweedie\"]] &lt;- glmmTMB(\n    temp_formula[[\"glmmTMB\"]][[\"untransformed\"]],\n    family = tweedie(link = \"log\"),\n    data = final_data_set\n  )\n  \n  message(\"Fitting glmmTMB to linear family...\")\n  fit[[outcome]][[\"glmmTMB\"]][[\"linear\"]] &lt;- glmmTMB(\n    temp_formula[[\"glmmTMB\"]][[\"untransformed\"]],\n    family = gaussian(link = \"identity\"),\n    data = final_data_set\n  )\n  \n  message(\"Fitting gee to linear family...\")\n  fit[[outcome]][[\"gee\"]][[\"linear\"]] &lt;- geeglm(\n    temp_formula[[\"gee\"]][[\"untransformed\"]],\n    id     = USRDS_ID,\n    data   = final_data_set,\n    corstr = \"exchangeable\",\n    family = gaussian(link = \"identity\"))  \n  \n  message(\n    \"Fitting models to formula: \", temp_formula[[\"glmmTMB\"]][[\"logtransformed\"]]\n  )\n  \n  message(\"Fitting glmmTMB to logcost family...\")\n  fit[[outcome]][[\"glmmTMB\"]][[\"log\"]] &lt;- glmmTMB(\n    temp_formula[[\"glmmTMB\"]][[\"logtransformed\"]],\n    family = gaussian(link = \"identity\"),\n    data = final_data_set\n  )\n  \n  message(\"Fitting gee to logcost family...\")\n  fit[[outcome]][[\"gee\"]][[\"log\"]] &lt;- geeglm(\n    temp_formula[[\"gee\"]][[\"logtransformed\"]],\n    id     = USRDS_ID,\n    data   = final_data_set,\n    corstr = \"exchangeable\",\n    family = gaussian(link = \"identity\"))  \n\n  \n}"
  },
  {
    "objectID": "quarto/figures.html",
    "href": "quarto/figures.html",
    "title": "Figures",
    "section": "",
    "text": "The code in this script generates figures for the manuscript."
  },
  {
    "objectID": "quarto/figures.html#figure-1",
    "href": "quarto/figures.html#figure-1",
    "title": "Figures",
    "section": "Figure 1",
    "text": "Figure 1\nThe following code uses the gt package to create a Table 1 comparing cases and controls on key variables measured at the index date, to assess balance after risk-set matching. The code then saves the tables as .docx and as .png files.\n\n\nCode\n#Create a table of the post-match results to confirm that demographics were appropriately balanced\ntable1&lt;-post_match_results%&gt;%\n  mutate(age=time_length(interval(BORN, index_date_match), \"years\"))%&gt;%\n  dplyr::select(cirrhosis, CMV, HIV, diabetes, cumulative_transplant_total, current_graft_status,\n                liver_transplant, lung_transplant, heart_transplant, heartlung_transplant,\n                pancreas_transplant, intestinal_transplant,\n                age, SEX, RACE, HISPANIC, RACEETH, RURALURBAN, cryptococcus_dx_date, \n         pancreas_transplant, intestinal_transplant, patient_type)%&gt;%\n  gtsummary::tbl_summary(by=patient_type)%&gt;%\n  add_p()\ntable1%&gt;%\n  gtsummary::as_gt() %&gt;%\n  gt::gtsave(\"tables/table1_baseline.png\")\nfile.exists(\"tables/table1_baseline.docx\") && file.remove(\"tables/table1_baseline.docx\")\ntable1%&gt;%\n  gtsummary::as_gt() %&gt;%\n  gt::gtsave(\"tables/table1_baseline.docx\")"
  },
  {
    "objectID": "quarto/figures.html#table-2",
    "href": "quarto/figures.html#table-2",
    "title": "Figures",
    "section": "Table 2",
    "text": "Table 2\nTable 2 lists the International Classification of Diseases (ICD-9 and ICD-10) diagnosis codes used to define baseline comorbidities in the study cohort. Comorbidity definitions were specified a priori in the R/setup.R file and implemented uniformly for cases and matched controls.\nCodes were grouped by clinical condition to reflect common diagnostic categories used in transplant and claims-based research. Both ICD-9 and ICD-10 codes were included to ensure continuity across calendar years spanning the ICD-9–to–ICD-10 transition period. For each comorbidity, all qualifying diagnosis codes are shown explicitly to promote transparency and reproducibility.\nThese comorbidity definitions were used for cohort construction, matching, and covariate adjustment, and were applied using diagnosis information available prior to or at the index date to avoid conditioning on post-exposure information.\nTable 2 is provided as a reference table to facilitate replication of the analytic pipeline and to allow readers to evaluate the clinical face validity of the claims-based comorbidity definitions.\n\n\nCode\n#Table of comorbidities generated from lists created in setup.R, then exported \n\ntable2_icd &lt;- comorbidity_ICD_list%&gt;%\n  imap_dfr(., \n           ~tibble(\n             comorbidity = .y,\n             icd_codes_raw = paste(.x, collapse = \", \")\n             )\n           )%&gt;%\n  gt() %&gt;%\n  cols_label(\n    comorbidity   = \"Comorbidity\",\n    icd_codes_raw = \"ICD Codes\"\n  ) %&gt;%\n  cols_width(\n    comorbidity   ~ px(220),\n    icd_codes_raw ~ px(500)\n  ) %&gt;%\n  tab_options(\n    table.font.size = px(12)\n  )%&gt;%\n  tab_header(\n  title = \"ICD-9 and ICD-10 Codes Used to Define Comorbidities\",\n  subtitle = \"Codes grouped by clinical condition\"\n)\ntable2_icd%&gt;%\n  gt::gtsave(\"tables/table2_baseline.png\")\nfile.exists(\"tables/table2_baseline.docx\") && file.remove(\"tables/table2_baseline.docx\")\ntable2_icd%&gt;%\n  gt::gtsave(\"tables/table2_baseline.docx\")"
  },
  {
    "objectID": "quarto/figures.html#cost-tables",
    "href": "quarto/figures.html#cost-tables",
    "title": "Figures",
    "section": "Cost tables",
    "text": "Cost tables\nThese tables use the total costs, not the modeled longitudinal costs. Cases and controls are compared. These tables are used for exploration and validation and are not intended for the manuscript.\n\n\nCode\n#Examine costs broken down by type\ncost_broken_down%&gt;%\n  select(patient_type, contains(c(\"IN_REV_365d_cost\", \"IN_CLM_365d_cost\", \"PS_REV_365d_cost\")))%&gt;%\n  gtsummary::tbl_summary(by=patient_type)%&gt;%\n  add_p()\n\n#Examine costs broken down by type and adjusted for inflation (medians)\ncost_inflated%&gt;%\n  select(patient_type, contains(c(\"IN_REV_365d_cost\", \"IN_CLM_365d_cost\", \"PS_REV_365d_cost\")))%&gt;%\n  gtsummary::tbl_summary(by=patient_type)%&gt;%\n  add_p()\n\ncost_inflated%&gt;%\n  select(patient_type, contains(c(\"IN_REV_365d_cost\", \"IN_CLM_365d_cost\", \"PS_REV_365d_cost\")))%&gt;%\n  gtsummary::tbl_summary(by=patient_type,\n                         statistic = all_continuous() ~ \"{mean} ({sd})\")%&gt;%\n  add_p()"
  },
  {
    "objectID": "quarto/figures.html#modeled-total-excess-costs",
    "href": "quarto/figures.html#modeled-total-excess-costs",
    "title": "Figures",
    "section": "Modeled total excess costs",
    "text": "Modeled total excess costs\nThis code uses the calculate_total_excess_costs() function in the R/functions.R file to estimate the total excess cost in cases compared with controls. see the functions site for more details about the internal workings of the function.\n\n\nCode\n#Total the grand difference between cases and controls over the entire period of follow up:\ncalculate_total_excess_costs(fit[[\"grand_total_cost_month\"]][[\"gee\"]][[\"linear\"]])"
  },
  {
    "objectID": "quarto/figures.html#other-portions-of-the-analysis",
    "href": "quarto/figures.html#other-portions-of-the-analysis",
    "title": "Figures",
    "section": "Other portions of the analysis",
    "text": "Other portions of the analysis\n\nAbout: methods, assumptions, and disclosures"
  },
  {
    "objectID": "quarto/tables.html",
    "href": "quarto/tables.html",
    "title": "Tables",
    "section": "",
    "text": "The code in this script generates tables for the manuscript."
  },
  {
    "objectID": "quarto/tables.html#table-1",
    "href": "quarto/tables.html#table-1",
    "title": "Tables",
    "section": "Table 1",
    "text": "Table 1\nThe following code uses the gt package to create a Table 1 comparing cases and controls on key variables measured at the index date, to assess balance after risk-set matching. The code then saves the tables as .docx and as .png files.\n\n\nCode\n#Create a table of the post-match results to confirm that demographics were appropriately balanced\ntable1&lt;-post_match_results%&gt;%\n  mutate(age=time_length(interval(BORN, index_date_match), \"years\"))%&gt;%\n  dplyr::select(cirrhosis, CMV, HIV, diabetes, cumulative_transplant_total, current_graft_status,\n                liver_transplant, lung_transplant, heart_transplant, heartlung_transplant,\n                pancreas_transplant, intestinal_transplant,\n                age, SEX, RACE, HISPANIC, RACEETH, RURALURBAN, cryptococcus_dx_date, \n         pancreas_transplant, intestinal_transplant, patient_type)%&gt;%\n  gtsummary::tbl_summary(by=patient_type)%&gt;%\n  add_p()\ntable1%&gt;%\n  gtsummary::as_gt() %&gt;%\n  gt::gtsave(\"tables/table1_baseline.png\")\nfile.exists(\"tables/table1_baseline.docx\") && file.remove(\"tables/table1_baseline.docx\")\ntable1%&gt;%\n  gtsummary::as_gt() %&gt;%\n  gt::gtsave(\"tables/table1_baseline.docx\")"
  },
  {
    "objectID": "quarto/tables.html#table-2",
    "href": "quarto/tables.html#table-2",
    "title": "Tables",
    "section": "Table 2",
    "text": "Table 2\nTable 2 lists the International Classification of Diseases (ICD-9 and ICD-10) diagnosis codes used to define baseline comorbidities in the study cohort. Comorbidity definitions were specified a priori in the R/setup.R file and implemented uniformly for cases and matched controls.\nCodes were grouped by clinical condition to reflect common diagnostic categories used in transplant and claims-based research. Both ICD-9 and ICD-10 codes were included to ensure continuity across calendar years spanning the ICD-9–to–ICD-10 transition period. For each comorbidity, all qualifying diagnosis codes are shown explicitly to promote transparency and reproducibility.\nThese comorbidity definitions were used for cohort construction, matching, and covariate adjustment, and were applied using diagnosis information available prior to or at the index date to avoid conditioning on post-exposure information.\nTable 2 is provided as a reference table to facilitate replication of the analytic pipeline and to allow readers to evaluate the clinical face validity of the claims-based comorbidity definitions.\n\n\nCode\n#Table of comorbidities generated from lists created in setup.R, then exported \n\ntable2_icd &lt;- comorbidity_ICD_list%&gt;%\n  imap_dfr(., \n           ~tibble(\n             comorbidity = .y,\n             icd_codes_raw = paste(.x, collapse = \", \")\n             )\n           )%&gt;%\n  gt() %&gt;%\n  cols_label(\n    comorbidity   = \"Comorbidity\",\n    icd_codes_raw = \"ICD Codes\"\n  ) %&gt;%\n  cols_width(\n    comorbidity   ~ px(220),\n    icd_codes_raw ~ px(500)\n  ) %&gt;%\n  tab_options(\n    table.font.size = px(12)\n  )%&gt;%\n  tab_header(\n  title = \"ICD-9 and ICD-10 Codes Used to Define Comorbidities\",\n  subtitle = \"Codes grouped by clinical condition\"\n)\ntable2_icd%&gt;%\n  gt::gtsave(\"tables/table2_baseline.png\")\nfile.exists(\"tables/table2_baseline.docx\") && file.remove(\"tables/table2_baseline.docx\")\ntable2_icd%&gt;%\n  gt::gtsave(\"tables/table2_baseline.docx\")"
  },
  {
    "objectID": "quarto/tables.html#cost-tables",
    "href": "quarto/tables.html#cost-tables",
    "title": "Tables",
    "section": "Cost tables",
    "text": "Cost tables\nThese tables use the total costs, not the modeled longitudinal costs. Cases and controls are compared. These tables are used for exploration and validation and are not intended for the manuscript.\n\n\nCode\n#Examine costs broken down by type\ncost_broken_down%&gt;%\n  select(patient_type, contains(c(\"IN_REV_365d_cost\", \"IN_CLM_365d_cost\", \"PS_REV_365d_cost\")))%&gt;%\n  gtsummary::tbl_summary(by=patient_type)%&gt;%\n  add_p()\n\n#Examine costs broken down by type and adjusted for inflation (medians)\ncost_inflated%&gt;%\n  select(patient_type, contains(c(\"IN_REV_365d_cost\", \"IN_CLM_365d_cost\", \"PS_REV_365d_cost\")))%&gt;%\n  gtsummary::tbl_summary(by=patient_type)%&gt;%\n  add_p()\n\ncost_inflated%&gt;%\n  select(patient_type, contains(c(\"IN_REV_365d_cost\", \"IN_CLM_365d_cost\", \"PS_REV_365d_cost\")))%&gt;%\n  gtsummary::tbl_summary(by=patient_type,\n                         statistic = all_continuous() ~ \"{mean} ({sd})\")%&gt;%\n  add_p()"
  },
  {
    "objectID": "quarto/tables.html#modeled-total-excess-costs",
    "href": "quarto/tables.html#modeled-total-excess-costs",
    "title": "Tables",
    "section": "Modeled total excess costs",
    "text": "Modeled total excess costs\nThis code uses the calculate_total_excess_costs() function in the R/functions.R file to estimate the total excess cost in cases compared with controls. see the functions site for more details about the internal workings of the function.\n\n\nCode\n#Total the grand difference between cases and controls over the entire period of follow up:\ncalculate_total_excess_costs(fit[[\"grand_total_cost_month\"]][[\"gee\"]][[\"linear\"]])"
  },
  {
    "objectID": "quarto/tables.html#other-portions-of-the-analysis",
    "href": "quarto/tables.html#other-portions-of-the-analysis",
    "title": "Tables",
    "section": "Other portions of the analysis",
    "text": "Other portions of the analysis\n\nAbout: methods, assumptions, and disclosures"
  },
  {
    "objectID": "quarto/functions.html",
    "href": "quarto/functions.html",
    "title": "Functions",
    "section": "",
    "text": "The code in this script generates tables for the manuscript."
  },
  {
    "objectID": "quarto/functions.html#table-1",
    "href": "quarto/functions.html#table-1",
    "title": "Tables",
    "section": "Table 1",
    "text": "Table 1\nThe following code uses the gt package to create a Table 1 comparing cases and controls on key variables measured at the index date, to assess balance after risk-set matching. The code then saves the tables as .docx and as .png files.\n\n\nCode\n#Create a table of the post-match results to confirm that demographics were appropriately balanced\ntable1&lt;-post_match_results%&gt;%\n  mutate(age=time_length(interval(BORN, index_date_match), \"years\"))%&gt;%\n  dplyr::select(cirrhosis, CMV, HIV, diabetes, cumulative_transplant_total, current_graft_status,\n                liver_transplant, lung_transplant, heart_transplant, heartlung_transplant,\n                pancreas_transplant, intestinal_transplant,\n                age, SEX, RACE, HISPANIC, RACEETH, RURALURBAN, cryptococcus_dx_date, \n         pancreas_transplant, intestinal_transplant, patient_type)%&gt;%\n  gtsummary::tbl_summary(by=patient_type)%&gt;%\n  add_p()\ntable1%&gt;%\n  gtsummary::as_gt() %&gt;%\n  gt::gtsave(\"tables/table1_baseline.png\")\nfile.exists(\"tables/table1_baseline.docx\") && file.remove(\"tables/table1_baseline.docx\")\ntable1%&gt;%\n  gtsummary::as_gt() %&gt;%\n  gt::gtsave(\"tables/table1_baseline.docx\")"
  },
  {
    "objectID": "quarto/functions.html#table-2",
    "href": "quarto/functions.html#table-2",
    "title": "Tables",
    "section": "Table 2",
    "text": "Table 2\nTable 2 lists the International Classification of Diseases (ICD-9 and ICD-10) diagnosis codes used to define baseline comorbidities in the study cohort. Comorbidity definitions were specified a priori in the R/setup.R file and implemented uniformly for cases and matched controls.\nCodes were grouped by clinical condition to reflect common diagnostic categories used in transplant and claims-based research. Both ICD-9 and ICD-10 codes were included to ensure continuity across calendar years spanning the ICD-9–to–ICD-10 transition period. For each comorbidity, all qualifying diagnosis codes are shown explicitly to promote transparency and reproducibility.\nThese comorbidity definitions were used for cohort construction, matching, and covariate adjustment, and were applied using diagnosis information available prior to or at the index date to avoid conditioning on post-exposure information.\nTable 2 is provided as a reference table to facilitate replication of the analytic pipeline and to allow readers to evaluate the clinical face validity of the claims-based comorbidity definitions.\n\n\nCode\n#Table of comorbidities generated from lists created in setup.R, then exported \n\ntable2_icd &lt;- comorbidity_ICD_list%&gt;%\n  imap_dfr(., \n           ~tibble(\n             comorbidity = .y,\n             icd_codes_raw = paste(.x, collapse = \", \")\n             )\n           )%&gt;%\n  gt() %&gt;%\n  cols_label(\n    comorbidity   = \"Comorbidity\",\n    icd_codes_raw = \"ICD Codes\"\n  ) %&gt;%\n  cols_width(\n    comorbidity   ~ px(220),\n    icd_codes_raw ~ px(500)\n  ) %&gt;%\n  tab_options(\n    table.font.size = px(12)\n  )%&gt;%\n  tab_header(\n  title = \"ICD-9 and ICD-10 Codes Used to Define Comorbidities\",\n  subtitle = \"Codes grouped by clinical condition\"\n)\ntable2_icd%&gt;%\n  gt::gtsave(\"tables/table2_baseline.png\")\nfile.exists(\"tables/table2_baseline.docx\") && file.remove(\"tables/table2_baseline.docx\")\ntable2_icd%&gt;%\n  gt::gtsave(\"tables/table2_baseline.docx\")"
  },
  {
    "objectID": "quarto/functions.html#cost-tables",
    "href": "quarto/functions.html#cost-tables",
    "title": "Tables",
    "section": "Cost tables",
    "text": "Cost tables\nThese tables use the total costs, not the modeled longitudinal costs. Cases and controls are compared. These tables are used for exploration and validation and are not intended for the manuscript.\n\n\nCode\n#Examine costs broken down by type\ncost_broken_down%&gt;%\n  select(patient_type, contains(c(\"IN_REV_365d_cost\", \"IN_CLM_365d_cost\", \"PS_REV_365d_cost\")))%&gt;%\n  gtsummary::tbl_summary(by=patient_type)%&gt;%\n  add_p()\n\n#Examine costs broken down by type and adjusted for inflation (medians)\ncost_inflated%&gt;%\n  select(patient_type, contains(c(\"IN_REV_365d_cost\", \"IN_CLM_365d_cost\", \"PS_REV_365d_cost\")))%&gt;%\n  gtsummary::tbl_summary(by=patient_type)%&gt;%\n  add_p()\n\ncost_inflated%&gt;%\n  select(patient_type, contains(c(\"IN_REV_365d_cost\", \"IN_CLM_365d_cost\", \"PS_REV_365d_cost\")))%&gt;%\n  gtsummary::tbl_summary(by=patient_type,\n                         statistic = all_continuous() ~ \"{mean} ({sd})\")%&gt;%\n  add_p()"
  },
  {
    "objectID": "quarto/functions.html#modeled-total-excess-costs",
    "href": "quarto/functions.html#modeled-total-excess-costs",
    "title": "Tables",
    "section": "Modeled total excess costs",
    "text": "Modeled total excess costs\nThis code uses the calculate_total_excess_costs() function in the R/functions.R file to estimate the total excess cost in cases compared with controls. see the functions site for more details about the internal workings of the function.\n\n\nCode\n#Total the grand difference between cases and controls over the entire period of follow up:\ncalculate_total_excess_costs(fit[[\"grand_total_cost_month\"]][[\"gee\"]][[\"linear\"]])"
  },
  {
    "objectID": "quarto/functions.html#other-portions-of-the-analysis",
    "href": "quarto/functions.html#other-portions-of-the-analysis",
    "title": "Functions",
    "section": "Other portions of the analysis",
    "text": "Other portions of the analysis\n\nAbout: methods, assumptions, and disclosures"
  },
  {
    "objectID": "quarto/figures.html#final-flowchart",
    "href": "quarto/figures.html#final-flowchart",
    "title": "Figures",
    "section": "Final flowchart",
    "text": "Final flowchart\nThe following code uses the flowchart package to create a STROBE flowchart for the study.\n\n\nCode\n#Final STROBE flowchart\npatients_fc_matched%&gt;%\n  fc_draw()%&gt;%\n  fc_export(\"figures/flowchart.svg\",\n            width=20,\n            height=10)"
  },
  {
    "objectID": "quarto/figures.html#beeswarm-plot-of-total-inflated-costs",
    "href": "quarto/figures.html#beeswarm-plot-of-total-inflated-costs",
    "title": "Figures",
    "section": "Beeswarm plot of total inflated costs",
    "text": "Beeswarm plot of total inflated costs\nThe following code uses the ggbeeswarm add-on to ggplot2 to compare cases and controls in terms of total inflated costs post-index. No attempt is made to adjust for censoring or death.\n\n\nCode\n#GGplot that is beeswarm of adjusted total costs\ncost_inflated%&gt;%\n  mutate(IN_CLM_365d_cost_adjusted_total=ifelse(IN_CLM_365d_cost_adjusted_total==0, 1, IN_CLM_365d_cost_adjusted_total))%&gt;%\n  ggplot()+\n  geom_quasirandom(mapping=aes(x=patient_type, y=IN_CLM_365d_cost_adjusted_total), alpha=0.1)+\n  scale_y_log10()+\n  theme_classic()"
  },
  {
    "objectID": "quarto/figures.html#month-by-month-plots",
    "href": "quarto/figures.html#month-by-month-plots",
    "title": "Figures",
    "section": "Month-by-month plots",
    "text": "Month-by-month plots\nIn order to plot monthly costs predicted from the longitudinal models generated in the R/models.R script, we use the plot_mean_monthly_costs() function from the R/functions.R script to create the ggplot objects, and then save as .svg files.\n\n\nCode\n#Loop that plots the different outcomes longitudinally\n\nfor (outcome in c(\"grand_total_cost_month\", \"IN_CLM_month_total\", \"PS_REV_month_total\", \"IN_CLM_month_groupedHomeHealth\",\n                  \"IN_CLM_month_groupedHospice\",\"IN_CLM_month_groupedNonclaimauxiliary\",\"IN_CLM_month_groupedDialysis\",\n                  \"IN_CLM_month_groupedOutpatient\",\"IN_CLM_month_groupedInpatient\",\"IN_CLM_month_groupedSkilledNursingFacility\")){\n  \n  \n  plot_mean_monthly_costs(fit[[outcome]][[\"glmmTMB\"]][[\"tweedie\"]])\n  ggsave(filename = paste0(\"figures/Longitudinal \", outcome,\" glmmTMB\", \" \", \"tweedie.svg\"),\n         width=14,\n         height=7\n         )\n  \n  plot_mean_monthly_costs(fit[[outcome]][[\"glmmTMB\"]][[\"linear\"]])\n  ggsave(filename = paste0(\"figures/Longitudinal \", outcome,\" glmmTMB\", \" \", \"linear.svg\"),\n         width=14,\n         height=7\n  )\n  \n  \n  plot_mean_monthly_costs(fit[[outcome]][[\"gee\"]][[\"linear\"]])\n  ggsave(filename = paste0(\"figures/Longitudinal \", outcome,\" gee\", \" \", \"linear.svg\"),\n         width=14,\n         height=7\n  )\n  \n  \n  plot_mean_monthly_costs(fit[[outcome]][[\"glmmTMB\"]][[\"log\"]])\n  ggsave(filename = paste0(\"figures/Longitudinal \", outcome,\" glmmTMB\", \" \", \"log.svg\"),\n         width=14,\n         height=7\n  )\n  \n  \n  plot_mean_monthly_costs(fit[[outcome]][[\"gee\"]][[\"log\"]])\n  ggsave(filename = paste0(\"figures/Longitudinal \", outcome,\" gee\", \" \", \"log.svg\"),\n         width=14,\n         height=7\n  )\n  \n  \n}"
  },
  {
    "objectID": "quarto/functions.html#plotting-mean-monthly-costs",
    "href": "quarto/functions.html#plotting-mean-monthly-costs",
    "title": "Functions",
    "section": "Plotting mean monthly costs",
    "text": "Plotting mean monthly costs\nThe following code uses the gt package to create a Table 1 comparing cases and controls on key variables measured at the index date, to assess balance after risk-set matching. The code then saves the tables as .docx and as .png files.\n\n\nCode\n#Function that returns a ggplot of the mean cost (with confidence interval) for cryptococcus cases and controls by month\nplot_mean_monthly_costs&lt;-function(fitted_model, countdf=final_count_df) {\n\n  #First, use emmeans to calculate the predicted values from the model assuming 30-day months, then convert to data frame\n  emm_df &lt;- emmeans(\n    fitted_model,\n    ~ patient_type | month,\n    at = list(month_offset = 30),\n    type = \"response\"\n  )%&gt;%as.data.frame()%&gt;%\n    \n    #Shifts all points and error_bars 0.5 to the right to avoid the zero-line\n    mutate(month=0.5+as.numeric(month))%&gt;%\n    \n    #Move cases 0.1 to the right and controls 0.1 to the left to improve legibility\n  mutate(month=ifelse(patient_type==\"Case\", month+0.1, month-0.1))%&gt;%\n    mutate(\n      estimate = if (\"response\" %in% names(.)) response else emmean)\n  \n  monthly_plot &lt;- list()\n  \n  # Main plot\n  monthly_plot[[\"main\"]] &lt;- ggplot(data = emm_df) +\n    geom_point(aes(x = month, y = estimate, color = patient_type)) +\n    geom_errorbar(\n      aes(\n        x = month,\n        ymin = asymp.LCL,\n        ymax = asymp.UCL,\n        color = patient_type\n      ),\n      width = 0.1\n    ) +\n    geom_vline(xintercept = 0,\n               linetype = \"dashed\",\n               color = \"gray50\") +\n    theme_classic() +\n    labs(\n      x = \"Month\",\n      y = \"Inflation-adjusted cost per month (dollars)\",\n      color = \"Patient group\"\n    )+\n    theme(legend.position = \"bottom\")\n  \n  # Risk table\n  monthly_plot[[\"risk_table\"]] &lt;- countdf %&gt;%\n    mutate(month = 0.5 + as.numeric(month),\n           y_position = ifelse(patient_type == \"Case\", 0.4, 0.6)) %&gt;%\n    ggplot() +\n    geom_text(\n      aes(x = month, y = y_position, label = n, color=patient_type),\n      size = 3\n    )+\n    coord_cartesian(ylim = c(0.3, 0.7)) +\n    theme_void() +\n    theme(\n      plot.margin = margin(t = -5, b = 5),\n      legend.position = \"none\")\n  \n  # Combine plots\n  monthly_plot[[\"main\"]] /\n    monthly_plot[[\"risk_table\"]] +\n    plot_layout(heights = c(9, 1), guides = \"keep\")+\n    plot_annotation(\n      caption = \"Bottom panel shows N at risk by month\"\n    )\n  \n}"
  },
  {
    "objectID": "quarto/functions.html#section",
    "href": "quarto/functions.html#section",
    "title": "Functions",
    "section": "",
    "text": "Code\n#Function that defines the number of potential control matches for a case\ncalculate_number_potential_matches&lt;-function(control_df,\n                                             USRDS_ID,\n                                             birthdate,\n                                             cirrhosis_status,\n                                             cmv_status,\n                                             hiv_status,\n                                             diabetes_status,\n                                             matching_date,\n                                             matching_days_since_transplant) {\n  \n  print(paste0(\"Calculating number of potential controls for patient: \", USRDS_ID))\n  control_df%&gt;%\n    \n    #Exact match on cirrhosis, CMV, HIV, and diabetes status\n    filter(cirrhosis==cirrhosis_status)%&gt;%\n    #  filter(CMV==cmv_status)%&gt;%\n    filter(HIV==hiv_status)%&gt;%\n    filter(diabetes==diabetes_status)%&gt;%\n    \n    #Risk set matching\n    filter(tstart&lt;=matching_days_since_transplant)%&gt;%\n    filter(tstop&gt;matching_days_since_transplant)%&gt;%\n    \n    #Calculate date for age calculations/etc.\n    mutate(.baseline_control_date=matching_days_since_transplant+most_recent_transplant_date)%&gt;%\n    \n    #Make sure case and control are sampled within 3 years of each other\n    filter(abs(time_length(interval(.baseline_control_date, matching_date), \"years\")) &lt;=3)%&gt;%\n    \n    #Date matching\n    #  filter(cohort_start_date&lt;=matching_date)%&gt;%\n    #  filter(cohort_stop_date&gt;matching_date)%&gt;%\n    \n    #Age&gt;=18 on index date\n    filter(time_length(interval(BORN, .baseline_control_date), \"years\") &gt;= 18)%&gt;%\n    \n    #Age difference under 10 years, calculated at sampling date\n    filter(abs(time_length(interval(BORN,.baseline_control_date), \"years\")-\n                 time_length(interval(birthdate,matching_date), \"years\")) &lt;=10)%&gt;%\n    \n    #Confirming 365 day Medicare lookback available for potential match\n    verify_medicare_primary(index_date = matching_date, medicare_coverage_df = medicare_history, cache=TRUE)%&gt;%\n    filter(medicare_primary_TF==TRUE)%&gt;%\n    \n    #Count rows after ensuring controls with mult transplants are only counted once \n    distinct(USRDS_ID)%&gt;%\n    nrow()%&gt;%\n    return()\n  \n}"
  },
  {
    "objectID": "quarto/functions.html#total-excess-costs",
    "href": "quarto/functions.html#total-excess-costs",
    "title": "Functions",
    "section": "Total excess costs",
    "text": "Total excess costs\n\n\nCode\n# Calculate total excess costs in a model\ncalculate_total_excess_costs &lt;- function(fitted_model, link = \"linear\") {\n  \n  # Extract coefficients and vcov matrix\n  coef_df &lt;- tidy(fitted_model)\n  vcov_matrix &lt;- vcov(fitted_model)\n  \n  # Get interaction terms\n  interaction_names &lt;- coef_df %&gt;% \n    filter(str_detect(term, \":\")) %&gt;% \n    pull(term)\n  \n  if (link == \"linear\") {\n    # Sum of coefficients\n    sum_estimate &lt;- coef_df %&gt;% \n      filter(term %in% interaction_names) %&gt;% \n      pull(estimate) %&gt;% \n      sum()\n    \n    # Variance of sum\n    sum_variance &lt;- vcov_matrix[interaction_names, interaction_names] %&gt;% \n      sum()\n    \n    # Standard error and CI\n    sum_se &lt;- sqrt(sum_variance)\n    df &lt;- df.residual(fitted_model)\n    \n    tibble(\n      estimate = sum_estimate,\n      std_error = sum_se,\n      conf_low = estimate - qt(0.975, df) * std_error,\n      conf_high = estimate + qt(0.975, df) * std_error,\n      statistic = estimate / std_error,\n      p_value = 2 * pt(-abs(statistic), df)\n    )\n    \n  } else if (link == \"log\") {\n    # Get coefficients for interactions\n    coefs &lt;- coef(fitted_model)[interaction_names]\n    vcov_sub &lt;- vcov_matrix[interaction_names, interaction_names]\n    \n    # Exponentiate each coefficient\n    exp_coefs &lt;- exp(coefs)\n    \n    # Sum of exponentiated coefficients\n    sum_estimate &lt;- sum(exp_coefs)\n    \n    # Delta method for variance\n    # Gradient: derivative of sum(exp(beta)) w.r.t. each beta is exp(beta)\n    gradient &lt;- exp_coefs\n    \n    # Variance using delta method\n    sum_variance &lt;- as.numeric(t(gradient) %*% vcov_sub %*% gradient)\n    sum_se &lt;- sqrt(sum_variance)\n    \n    # CI using normal approximation (GLM)\n    tibble(\n      estimate = sum_estimate,\n      std_error = sum_se,\n      conf_low = estimate - qnorm(0.975) * std_error,\n      conf_high = estimate + qnorm(0.975) * std_error,\n      statistic = estimate / std_error,\n      p_value = 2 * pnorm(-abs(statistic))\n    )\n    \n  } else {\n    stop(\"link must be either 'linear' or 'log'\")\n  }\n}"
  }
]